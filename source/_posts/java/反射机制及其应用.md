---
 title: 反射机制及其应用
categories:
  - 好好学习
tags:
  - Java
date: 2019-08-13 21:19:46
---


反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。
本文首先介绍反射相关的Class类对象、反射的作用等相关概念，
然后讲反射技术在JDBC、Spring IOC、动态代理等方面的应用。

<!-- more -->

## 反射相关概念

反射机制能够在运行时对类进行装载，能够增加程序的灵活性，但是不恰当的使用反射机制，会严重影响系统的性能。

### 类对象Clazz

类对象的概念：所有的类，都存在一个类对象。这个类对象用于提供**类本身**的信息，比如有几种构造法方法，有多少属性，有哪些方法。

### 获取类对象

获取类对象的方式有三种：

1. `Class.forName(String className)`
2. `className.class`
3. `实例.getClass()`,  例如new Hero().getClass()

在同一个JVM中，一种类只有一个类对象存在。

### 反射的作用

反射机制提供的功能：

- 得到一个对象所属的类
- 获取一个类的所有的成员变量和方法
- 在运行时创建对象
- 运行时调用对象的方法

#### 运行时创建对象

与传统的通过new创造一个对象的方式不同，反射机制，先拿到类的类对象，通过类对象获取构造器对象，通过构造器对象创造对象。

```java
package reflection;
import java.lang.reflect.Constructor;
import charactor.Hero;
public class TestReflection {
  
    public static void main(String[] args) {
        //传统的使用new的方式创建对象
        Hero h1 =new Hero();
        h1.name = "teemo";
        System.out.println(h1);
          
        try {
            //使用反射的方式创建对象
            String className = "charactor.Hero";
            //类对象
            Class pClass=Class.forName(className);
            //构造器
            Constructor c= pClass.getConstructor();
            //通过构造器实例化
            Hero h2= (Hero) c.newInstance();
            h2.name="gareen";
            System.out.println(h2);
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
```

#### 访问属性

#### 调用方法



## 反射技术的应用

### JDBC连接数据库

在JDBC 的操作中，如果要想进行数据库的连接，则必须按照以上的几步完成

1. 通过`Class.forName()`加载数据库的驱动程序 （通过反射加载，前提是引入相关了Jar包）
2. 通过 `DriverManager `类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密码
3. 通过Connection 接口接收连接

```java
public class ConnectionJDBC {  
  
    /** 
     * @param args 
     */  
    //驱动程序就是之前在classpath中配置的JDBC的驱动程序的JAR 包中  
    public static final String DBDRIVER = "com.mysql.jdbc.Driver";  
    //连接地址是由各个数据库生产商单独提供的，所以需要单独记住  
    public static final String DBURL = "jdbc:mysql://localhost:3306/test";  
    //连接数据库的用户名  
    public static final String DBUSER = "root";  
    //连接数据库的密码  
    public static final String DBPASS = "";  
      
      
    public static void main(String[] args) throws Exception {  
        Connection con = null; //表示数据库的连接对象  
        Class.forName(DBDRIVER); //1、使用CLASS 类加载驱动程序 ,反射机制的体现 
        con = DriverManager.getConnection(DBURL,DBUSER,DBPASS); //2、连接数据库  
        System.out.println(con);  
        con.close(); // 3、关闭数据库  
    } 
}
```

### Spring 框架的使用

- Spring 框架的使用

  在 Java的反射机制在做基础框架的时候非常有用，行内有一句这样的老话：反射机制是Java框架的基石。一般应用层面很少用，不过这种东西，现在很多开源框架基本都已经封装好了，自己基本用不着写。典型的除了hibernate之外，还有spring也用到很多反射机制。最经典的就是xml的配置模式。

Spring 通过 XML 配置模式装载 Bean 的过程：

1. 将程序内所有 XML 或 Properties 配置文件加载入内存中
2. Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息
3. 使用反射机制，根据这个字符串获得某个类的Class实例
4. 动态配置实例的属性

Spring这样做的好处是：

- 不用每一次都要在代码里面去new或者做其他的事情
- 以后要改的话直接改配置文件，代码维护起来就很方便了
- 有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现

模拟 Spring 加载 XML 配置文件：

```java
public class BeanFactory {
    private Map<String, Object> beanMap = new HashMap<String, Object>();
    	/**
       * bean工厂的初始化.
       * @param xml xml配置文件
       */
    public void init(String xml) {
        try {
            //读取指定的配置文件
            SAXReader reader = new SAXReader();
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
            //从class目录下获取指定的xml文件
            InputStream ins = classLoader.getResourceAsStream(xml);
            Document doc = reader.read(ins);
            Element root = doc.getRootElement();  
            Element foo;

            //遍历bean
            for (Iterator i = root.elementIterator("bean"); i.hasNext();) {  
                foo = (Element) i.next();
                //获取bean的属性id和class
                Attribute id = foo.attribute("id");  
                Attribute cls = foo.attribute("class");

                //利用Java反射机制，通过class的名称获取Class对象
                Class bean = Class.forName(cls.getText());

                //获取对应class的信息
                java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(bean);
                //获取其属性描述
                java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors();
                //设置值的方法
                Method mSet = null;
                //创建一个对象
                Object obj = bean.newInstance();

                //遍历该bean的property属性
                for (Iterator ite = foo.elementIterator("property"); ite.hasNext();) {  
                    Element foo2 = (Element) ite.next();
                    //获取该property的name属性
                    Attribute name = foo2.attribute("name");
                    String value = null;

                    //获取该property的子元素value的值
                    for(Iterator ite1 = foo2.elementIterator("value"); ite1.hasNext();) {
                        Element node = (Element) ite1.next();
                        value = node.getText();
                        break;
                    }

                    for (int k = 0; k < pd.length; k++) {
                        if (pd[k].getName().equalsIgnoreCase(name.getText())) {
                            mSet = pd[k].getWriteMethod();
                            //利用Java的反射极致调用对象的某个set方法，并将值设置进去
                            mSet.invoke(obj, value);
                        }
                    }
                }

                //将对象放入beanMap中，其中key为id值，value为对象
                beanMap.put(id.getText(), obj);
            }
        } catch (Exception e) {
            System.out.println(e.toString());
        }
    }

    //other codes
}
```

### Spring IOC

IOC：即控制反转，不是什么技术，而是一种思想。使用IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。

接下来主要讲解一下IOC底层实现的原理（反射），Bean容器的实现，就不对IOC的概念进行详述了。

在[spring](http://lib.csdn.net/base/javaee)的配置文件中，经常看到如下配置：

```html
<bean id="courseDao" class="com.qcjy.learning.Dao.impl.CourseDaoImpl"></bean>  
```

那么通过这样配置，Spring是怎么帮我们实例化对象，并且放到容器中去了了？对，就是通过反射！！！



下面是Spring通过配置进行实例化对象，并放到容器中的伪代码：

```java
//解析<bean .../>元素的id属性得到该字符串值为“courseDao”  
String idStr = "courseDao";  
//解析<bean .../>元素的class属性得到该字符串值为“com.qcjy.learning.Dao.impl.CourseDaoImpl”  
String classStr = "com.qcjy.learning.Dao.impl.CourseDaoImpl";  
//利用反射知识，通过classStr获取Class类对象  
Class<?> cls = Class.forName(classStr);  
//实例化对象  
Object obj = cls.newInstance();  
//container表示Spring容器  
container.put(idStr, obj); 
```

通过解析xml文件，获取到id属性和class属性里面的内容，利用反射原理获取到配置里面类的实例对象，存入到Spring的bean容器中。



当一个类里面需要应用另一类的对象时，Spring的配置如下所示：

```html
<bean id="courseService" class="com.qcjy.learning.service.impl.CourseServiceImpl">  
     <!-- 控制调用setCourseDao()方法，将容器中的courseDao bean作为传入参数 -->  
     <property name="courseDao" ref="courseDao"></property>  
</bean>  
```

我们继续用伪代码的形式来模拟实现一下Spring底层处理原理：

```java
//解析<property .../>元素的name属性得到该字符串值为“courseDao”  
String nameStr = "courseDao";  
//解析<property .../>元素的ref属性得到该字符串值为“courseDao”  
String refStr = "courseDao";  
//生成将要调用setter方法名  setCourseDao
String setterName = "set" + nameStr.substring(0, 1).toUpperCase()  
        + nameStr.substring(1);  
//获取spring容器中名为refStr的Bean，该Bean将会作为传入参数  
Object paramBean = container.get(refStr);  
//获取setter方法的Method类，此处的cls是刚才反射代码得到的Class对象  
Method setter = cls.getMethod(setterName, paramBean.getClass());  
//调用invoke()方法，此处的obj是刚才反射代码得到的Object对象  
setter.invoke(obj, paramBean);  
```

通过上面对Spring底层原理的分析，可以发现，其实并不难，用到的都是反射机制，通过反射实例化对象，存入到Spring的bean容器中。

只要在代码或配置文件中看到类的完整路径（包.类），其底层原理基本上使用的就是[Java](http://lib.csdn.net/base/java)的反射机制。

### 动态代理

动态代理是反射的一个非常重要的应用场景。动态代理常被用于一些 Java 框架中。例如 Spring 的 AOP ，Dubbo 的 SPI 接口，就是基于 Java 动态代理实现的。

#### 静态代理

> 静态代理其实就是指设计模式中的代理模式。
>
> **代理模式为其他对象提供一种代理以控制对这个对象的访问。**



![img](https://user-gold-cdn.xitu.io/2019/3/26/169bab47c6f5fba0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





**Subject** 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。

```java
abstract class Subject {
    public abstract void Request();
}
```

**RealSubject** 定义 Proxy 所代表的真实实体。

```java
class RealSubject extends Subject {
    @Override
    public void Request() {
        System.out.println("真实的请求");
    }
}
```

**Proxy** 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。

```java
class Proxy extends Subject {
    private RealSubject real;

    @Override
    public void Request() {
        if (null == real) {
            real = new RealSubject();
        }
        real.Request();
    }
}
```

> 说明：
>
> 静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和 RealSubject 的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。

#### 动态代理

为了解决静态代理的问题，就有了创建动态代理的想法：

在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了。



![img](https://user-gold-cdn.xitu.io/2019/3/26/169bab47c71af9bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





Java 动态代理基于经典代理模式，引入了一个 InvocationHandler，InvocationHandler 负责统一管理所有的方法调用。

动态代理步骤：

1. 获取 RealSubject 上的所有接口列表；
2. 确定要生成的代理类的类名，默认为：`com.sun.proxy.$ProxyXXXX`；
3. 根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；
4. 将对应的字节码转换为对应的 class 对象；
5. 创建 `InvocationHandler` 实例 handler，用来处理 `Proxy` 所有方法调用；
6. Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。

从上面可以看出，JDK 动态代理的实现是基于实现接口的方式，使得 Proxy 和 RealSubject 具有相同的功能。

但其实还有一种思路：通过继承。即：让 Proxy 继承 RealSubject，这样二者同样具有相同的功能，Proxy 还可以通过重写 RealSubject 中的方法，来实现多态。CGLIB 就是基于这种思路设计的。

在 Java 的动态代理机制中，有两个重要的类（接口），一个是 `InvocationHandler` 接口、另一个则是 `Proxy` 类，这一个类和一个接口是实现我们动态代理所必须用到的。

#### InvocationHandler 接口

`InvocationHandler` 接口定义：

```
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
复制代码
```

每一个动态代理类都必须要实现 `InvocationHandler` 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 `InvocationHandler` 这个接口的 `invoke` 方法来进行调用。

我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：

```
Object invoke(Object proxy, Method method, Object[] args) throws Throwable
复制代码
```

参数说明：

- **proxy** - 代理的真实对象。
- **method** - 所要调用真实对象的某个方法的 `Method` 对象
- **args** - 所要调用真实对象某个方法时接受的参数

如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。

#### Proxy 类

`Proxy` 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 `newProxyInstance` 这个方法：

```
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,  InvocationHandler h)  throws IllegalArgumentException
复制代码
```

这个方法的作用就是得到一个动态的代理对象。

参数说明：

- **loader** - 一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载。
- **interfaces** - 一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了
- **h** - 一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上

#### 动态代理实例

上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：

首先我们定义了一个 Subject 类型的接口，为其声明了两个方法：

```
public interface Subject {

    void hello(String str);

    String bye();
}
复制代码
```

接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject 类：

```
public class RealSubject implements Subject {

    @Override
    public void hello(String str) {
        System.out.println("Hello  " + str);
    }

    @Override
    public String bye() {
        System.out.println("Goodbye");
        return "Over";
    }
}
复制代码
```

下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：

```
public class InvocationHandlerDemo implements InvocationHandler {
    // 这个就是我们要代理的真实对象
    private Object subject;

    // 构造方法，给我们要代理的真实对象赋初值
    public InvocationHandlerDemo(Object subject) {
        this.subject = subject;
    }

    @Override
    public Object invoke(Object object, Method method, Object[] args)
        throws Throwable {
        // 在代理真实对象前我们可以添加一些自己的操作
        System.out.println("Before method");

        System.out.println("Call Method: " + method);

        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用
        Object obj = method.invoke(subject, args);

        // 在代理真实对象后我们也可以添加一些自己的操作
        System.out.println("After method");
        System.out.println();

        return obj;
    }
}
复制代码
```

最后，来看看我们的 Client 类：

```
public class Client {
    public static void main(String[] args) {
        // 我们要代理的真实对象
        Subject realSubject = new RealSubject();

        // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的
        InvocationHandler handler = new InvocationHandlerDemo(realSubject);

        /*
         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数
         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象
         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了
         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上
         */
        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject
                .getClass().getInterfaces(), handler);

        System.out.println(subject.getClass().getName());
        subject.hello("World");
        String result = subject.bye();
        System.out.println("Result is: " + result);
    }
}
复制代码
```

我们先来看看控制台的输出：

```
com.sun.proxy.$Proxy0
Before method
Call Method: public abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)
Hello  World
After method

Before method
Call Method: public abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()
Goodbye
After method

Result is: Over
复制代码
```

我们首先来看看 `com.sun.proxy.$Proxy0` 这东西，我们看到，这个东西是由 `System.out.println(subject.getClass().getName());` 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？

```
Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject
                .getClass().getInterfaces(), handler);
复制代码
```

可能我以为返回的这个代理对象会是 Subject 类型的对象，或者是 InvocationHandler 的对象，结果却不是，首先我们解释一下**为什么我们这里可以将其转化为 Subject 类型的对象？**

原因就是：在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 Subject 类型，所以就可以将其转化为 Subject 类型了。

**同时我们一定要记住，通过 Proxy.newProxyInstance 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy 为中，最后一个数字表示对象的标号**。

接着我们来看看这两句

```
subject.hello("World");
String result = subject.bye();
复制代码
```

这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。

我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：

```
public abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)
public abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()
复制代码
```

正好就是我们的 Subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。

## 小结

![](https://user-gold-cdn.xitu.io/2019/3/26/169bab47c743e3ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 参考资料

[Java反射机制在Spring IOC中的应用](http://www.ishenping.com/ArtInfo/1655649.html)

[Reflection：Java反射机制的应用场景](https://segmentfault.com/a/1190000010162647)

[深入理解 Java 反射和动态代理](https://juejin.im/post/5c9a4b10f265da60f6731913#heading-16)