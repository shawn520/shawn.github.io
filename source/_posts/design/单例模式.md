---
title: 单例模式
categories:
- 好好学习
tags:
  - Design Pattern
date: 2018-07-06 20:19:46
---

# 单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
![单例模式](https://i.loli.net/2018/10/13/5bc15fd836737.png)

<!-- more -->

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

## 介绍

意图：保证一个类只有一个实例，并提供一个访问它的全局访问点。

主要解决：一个全局使用的类频繁的被创建和销毁。

关键代码：构造函数私有化。

优点：在内存里只有一个实例，减小了对内存的开销。

缺点：没有接口，不能继承，与单一职责冲突，一个类只关心内部逻辑，而不关心外面怎么实现它。

使用场景：

1. 要求生产序列号唯一
2. web中的计数器，不想每次刷新都在数据库中加一次，用单例模式先缓存起来。
3. 创建一个对象需要消耗的资源过多，比如I/O与数据库的连接等。

## 实现

我们将创建一个 *SingleObject* 类。*SingleObject* 类有它的私有构造函数和本身的一个静态实例。 

*SingleObject* 类提供了一个静态方法，供外界获取它的静态实例。*SingletonPatternDemo*，我们的演示类使用 *SingleObject* 类来获取 *SingleObject* 对象。

![](http://www.runoob.com/wp-content/uploads/2014/08/singleton_pattern_uml_diagram.jpg)

1. 创建一个Singleton类

   ```java
   
   public class SingleObject {
    
      //创建 SingleObject 的一个对象
      private static SingleObject instance = new SingleObject();
    
      //让构造函数为 private，这样该类就不会被实例化
      private SingleObject(){}
    
      //获取唯一可用的对象
      public static SingleObject getInstance(){
         return instance;
      }
    
      public void showMessage(){
         System.out.println("Hello World!");
      }
   }
   
   ```

2. 从Singleton类获取唯一个对象。

   ```java
   public class SingletonPatternDemo {
      public static void main(String[] args) {
    
         //不合法的构造函数
         //编译时错误：构造函数 SingleObject() 是不可见的
         //SingleObject object = new SingleObject();
    
         //获取唯一可用的对象
         SingleObject object = SingleObject.getInstance();
    
         //显示消息
         object.showMessage();
      }
   }
   
   ```

3. 执行程序，输出结果：

   ```java
   Hello World!
   ```

## 单例模式的几种实现方式

### 一、懒汉式，线程不安全

是否lazy初始化： 是

是否多线程安全：否

实现难度：容易

描述：这种方式是最进本的实现方式，最大的问题是不支持多线程。因为没有加synchronized，当多线程访问的时候，可能同时创建多个实例，所以从多线程上来看，并不算作单例模式。

这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。

```java

public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}

```

接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。

### 二、懒汉式，线程安全

是否lazy初始化：是

是否线程安全：是

实现难度：容易

描述：具备很好的lazy loading, 多线程安全，但是效率低下。

优点：懒加载，避免内存浪费。

缺点：

```java

public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public static synchronized Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
```

### 三、饿汉式

是否lazy初始化：否

是否多线程安全：是

实现难度：容易

描述：这种方法比较常用，但是容易产生垃圾对象。

优点：没有加锁，执行效率高。

缺点：类加载时就初始化，浪费内存。

```java

public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}

```



### 四、双检锁/双重校验锁（DCL，即 double-checked locking）

是否lazy初始化：是

是否多线程安全：是

实现难度：较复杂

描述：这种方式线程安全，且在多线程的情况下，能保证高性能。

```java

public class Singleton {  
    private volatile static Singleton singleton;  //多线程访问情形下，阻止编译器自动优化。
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (null == singleton) {  
        synchronized (Singleton.class) {  
        if (null == singleton) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}

```

## 参考资料

https://www.runoob.com/design-pattern/design-pattern-tutorial.html



