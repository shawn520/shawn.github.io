<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[费曼学习法]]></title>
    <url>%2F2019%2F07%2F12%2Fstudy%2F%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习一个新的知识的时候，有没有一种茶壶里煮饺子，有货到不出的感觉？明明这个知识点我已经明白了，“掌握”的很好了，但是别人问我的时候，还是闪烁其词，讲不明白？遇到相同问题或者类似问题时，还是不会运用。 我们需要一个高效的学习方法–费曼学习法 什么是费曼学习法？费曼学习法就是以通俗的语言来向别人传授你刚学到的知识点。平时我们的学习大部分都是被动的学习，或者说，学习的知识都没有很好的的到应用。比如说新学了一个知识点，能正确理解知识点的内容，以为自己已经掌握了，其实不然。学习有输入和输出两个过程，理解了知识点并不代表已经掌握了，就像茶壶里煮饺子，有货倒不出一样。如果能做到将高深的理论知识以通俗易懂的方式，解释给一个外行人听的话，才能说明真正掌握了这个知识。本质上来说：是以大妈级的语言来解释一些专业上的问题，用我们日常随处可见的现象来解释专业上的问题。总之：他是用极其具象的东西来回答高度抽象的东西。 费曼学习法的步骤费曼学习法分为四个步骤。 首先，假设你要把将要学习的知识传授给一个智力大概在8岁左右的小孩子，应该如何做，传授过程中是否有卡壳？如果有卡壳的地方，恰恰说明这里没有掌握，然后带着疑问重新学习资料，回顾。直到没有障碍为止，然后再简化语言，并将语言条理化。 123456graph LRA[假设需要传授给一个小孩子] --&gt; B&#123;是否卡壳?&#125;B -.-&gt;|是| C[回顾]C --&gt;A[假设需要传授给一个小孩子]B --&gt;|否| D[语言条理化, 简单化] 一、把它教给一个小孩子拿出一张白纸，在上方写下你想要学习的主题。想一下，如果你要把它教给一个孩子，你会讲哪些，并写下来。这里你的教授对象不是你自己那些聪明的成年朋友，而是一个 8 岁的孩子，他的词汇量和注意力刚好能够理解基本概念和关系。 许多人会倾向于使用复杂的词汇和行话来掩盖他们不明白的东西。问题是我们只在糊弄自己，因为我们不知道自己也不明白。另外，使用行话会隐藏周围人对我们的误解。 当你自始至终都用孩子可以理解的简单的语言写出一个想法（提示：只用最常见的单词），那么你便迫使自己在更深层次上理解了该概念，并简化了观点之间的关系和联系。如果你努力，就会清楚地知道自己在哪里还有不明白的地方。这种紧张状态很好——预示着学习的机会到来了。 二、回顾在第一步中，你不可避免地会卡壳，忘记重要的点，不能解释，或者说不能将重要的概念联系起来。 这一反馈相当宝贵，因为你已经发现了自己知识的边缘。懂得自己能力的界限也是一种能力，你刚刚就确定了一个！ 这是学习开始的地方。现在你知道自己在哪里卡住了，那么就回到原始材料，重新学习，直到你可以用基本的术语解释这一概念。 认定自己知识的界限，会限制你可能犯的错误，并且在应用该知识时，可以增加成功的几率。 三、将语言条理化，简化现在你手上有一套自己手写笔记，检查一下确保自己没有从原材料中借用任何行话。将这些笔记用简单的语言组织成一个流畅的故事。 将这个故事大声读出来，如果这些解释不够简单，或者听起来比较混乱，很好，这意味着你想要理解该领域，还需要做一些工作。 四、传授如果你真的想确保你的理解没什么问题，就把它教给另一个人（理想状态下，这个人应该对这个话题知之甚少，或者就找个 8 岁的孩子）。检测知识最终的途径是你能有能力把它传播给另一个人。 实践参考文献https://www.quora.com/Learning-New-Things/How-can-you-learn-faster/answer/Acaz-Pereira https://www.zhihu.com/question/20576786 https://wiki.mbalib.com/wiki/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>高效学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA如何实现原子操作？]]></title>
    <url>%2F2019%2F07%2F10%2Fjava%2FJAVA%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[java可以通过锁和循环CAS的方式实现原子操作。那么如何通过循环CAS的方式实现Java的原子操作呢？ 循环CAS实现原子操作循环CAS的基本思路就是通过循环执行CAS操作，直到执行成功跳出循环。以下代码实现基于CAS线程安全的计数器方法safeCount()和非线程安全计数器count。初始化100个线程，每个线程执行1w次计数,线程安全的结果应该是100w,而非线程安全的结果可能会小于这个数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Counter &#123; private AtomicInteger atomicI = new AtomicInteger(0); private int i = 0; public static void main(String[] args) &#123; final Counter cas = new Counter(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(600); long start = System.currentTimeMillis(); //初始化100个线程，每个线程执行1w次计数 for(int j=0; j&lt;100; j++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i=0; i&lt;10000; i++)&#123; cas.safeCount(); cas.count(); &#125; &#125; &#125;); threads.add(thread); &#125; for (Thread thread : threads) &#123; thread.start(); &#125; //等待所有线程执行完成 for(Thread thread : threads) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //非线程安全的结果:&lt;100w System.out.println(cas.i); //线程安全的结果: 100w System.out.println(cas.atomicI.get()); System.out.println(System.currentTimeMillis() - start); &#125; /** * 使用CAS实现线程安全计数 */ private void safeCount() &#123; //自旋CAS,直到成功跳出循环 for(;;) &#123; int i = atomicI.get(); boolean suc = atomicI.compareAndSet(i, ++i); if (suc) &#123; break; &#125; &#125; &#125; /** * 非线程安全计数 */ private void count() &#123; i++; &#125;&#125; CAS实现原子操作的问题循环CAS存在三大问题：ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作。 ABA问题什么是ABA问题？如果一个值原来是A，变成了B，又变成了A。那么CAS认为值没有发生变化，实际上是发生了变化的。 解决思路：在变量前面追加版本号A -&gt; B -&gt; A就会变成1A -&gt; 2B -&gt; 3A 这里是完整的 代码。 参考资料：方腾飞《Java并发编程的艺术》]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Climbing Stairs]]></title>
    <url>%2F2019%2F07%2F09%2FleetCode%2FClimbing%20Stairs%2F</url>
    <content type="text"><![CDATA[Climbing Stairs爬梯子问题是一个斐波那契问题，同时也是一个简单的动态规划问题，如何通过动态规划的方式解决爬梯子问题呢？ 问题描述You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2Output: 2Explanation: There are two ways to climb to the top. 1 step + 1 step 2 stepsExample 2: Input: 3Output: 3Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step 思路分析这是一个Fibonacci问题。 从动态规划的角度来看，可以看作是一个简单的动态规划问题。 针对一个动态规划问题，我们一般分为四步来进行解决： 寻找问题的最优子结构 从上往下递归 边界值 从下往上求解 代码实现递归实现： 1234567891011public int climbStairs(int n) &#123; if(0 == n) &#123; return 0; &#125; else if(1 == n) &#123; return 1; &#125; else if(2 == n) &#123; return 2; &#125; return climbStairs(n-1) + climbStairs(n-2);&#125; 递归实现的时间复杂度为O(2^n). 含有大量重复的操作。 自底向上非递归实现: 123456789101112131415161718public int climbStairs(int n) &#123; if(0 &gt;= n) &#123; return 0; &#125; else if(1 == n) &#123; return 1; &#125; else if(2 == n) &#123; return 2; &#125; int a = 1; int b = 2; for(int i = 3; i &lt;= n; i++) &#123; int temp = a + b; a = b; b = temp; &#125; return b;&#125; 非递归实现的时间复杂度为O(n), 空间复杂度为O(1). 具体代码实现 参考资料参考资料1]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北大南门海淀路社区次卧单间近爱奇艺，头条，微软]]></title>
    <url>%2F2019%2F06%2F02%2Flife%2F%E5%8C%97%E5%A4%A7%E5%8D%97%E9%97%A8%E6%B5%B7%E6%B7%80%E8%B7%AF%E7%A4%BE%E5%8C%BA%E6%AC%A1%E5%8D%A7%E5%8D%95%E9%97%B4%E8%BF%91%E7%88%B1%E5%A5%87%E8%89%BA%EF%BC%8C%E5%A4%B4%E6%9D%A1%EF%BC%8C%E5%BE%AE%E8%BD%AF%2F</url>
    <content type="text"><![CDATA[一、基本信息时间 ： 6月中旬。位置 ： 北大南门海淀路社区，近爱奇艺，头条，微软亚洲研究院等。近中关村地铁站A口，500m内。价格 ： 房租3000元一个月，押一付三。无中介费，这个价格在附近很划算。 二、房间介绍要转租的是朝北次卧，可住一到两人。房间空调，冰箱，厨房用具，热水器，暖气齐全，可能是由于给北大职工住的，冬天供暖不收费。民用峰谷电，平常5毛多，夜间2毛多。下面是房间的一些照片。[图2-1 小区门口] [图2-2 房间全局] [图2-3 窗外的景色也不错] [图2-4 房间局部 ] [图2-5 厨房] [图2-6 小区外景] [图2-7 小区外景] 三、周边介绍距离北大南门超近，周末或者晚上吃过饭后可以去北大未名湖畔溜达一圈，或者去北大五四体育场夜跑都是不错的选择。附近吃的很多，可以去食宝街，钻食街，鼎好五层，北大，人大食堂还有欧美汇，新中关gate等，也可以厨房自己DIY。小区楼下有早点，饭店，很齐全，买蔬菜水果也很方便。日常生活用品可以去附近的物美超市或者家乐福。下面是去北大溜达时候拍的一些照片。[图3-1 北大南门] [图3-2 北大百周年纪念讲堂] [图3-3 秋天的北大] [图3-4 北大五四路] [图3-5 春天北大的大雅堂] [图3-6 北大光华管理学院] 四、问题汇总【问】先问下 合同和谁签呀~【答】可以和本人签或者和中介签。和中介签需要交500转租费。 【问】你这个什么时候到期？【答】2020年4月份 【问】是几居室？有隔断吗？【答】三居室，三室一厅一厨一卫。没有隔断。 【问】除了房租、水电燃气均摊？【答】是的。 【问】厨房可用吗？【答】可以。 【问】几楼…有无电梯~【答】一共6层，房间在5楼，没有电梯。 【问】卫生间淋浴是用燃气还是用电的？【答】卫生间淋浴用燃气。 【问】房间大概多大？【答】房价大概15平左右。 【问】室友有几个人呀，都是男生女生呀？【答】三个女生 一个男生。附近上班，作息规律，都很好相处。 五、联系方式感谢您的阅读。如有意，请扫码加微信。 [图4-1 wechat]]]></content>
      <categories>
        <category>缤纷生活</category>
      </categories>
      <tags>
        <tag>缤纷生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web项目如何获取表的ddl信息？]]></title>
    <url>%2F2019%2F04%2F04%2Fjava%2FJava%20Web%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%A1%A8%E7%9A%84ddl%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[背景：公司项目是做MySQL数据向同构和异构数据库同步和消息订阅的。在做向消息中间件RMQ同步时，需要根据源表的表信息，在目标数据库创建一个相同的逻辑表。 如果是用shell的话：show create table tableName就可以搞定啦。这里一共有两个参数，第一个是table，第二个是create Table, 我们需要的就是create Table的建表语句。但是这个用Java怎么实现呢？ Mybatis这块暂且还不知道怎么实现，先通过jdbc来实现查询表的ddl语句。思路一：通过执行show create table tableName思路二：show create table tablename 和show databases 可能查的是MySQL的数据库information_schema。 123SELECT * FROM information_schema.columns where TABLE_SCHEMA = "test" AND TABLE_NAME = "example" LIMIT 10;SELECT * FROM information_schema.tables where TABLE_SCHEMA = "test" AND TABLE_NAME = "example" LIMIT 10; 可以根据以上等信息去组装ddl语句，比较复杂，而且账号的权限不一定够。所以这里按思路一的方式。首先是数据库的连接： 123456789101112131415161718192021public class DBUtil &#123; static final Logger logger = LoggerFactory.getLogger(DBUtil.class); private static final String DRIVER = "com.mysql.jdbc.Driver"; private static final String USER = "root"; private static final String PASSWORD = "admin"; private static final String DATABASE = "jdbc:mysql://127.0.0.1:3306/TEST"; public static Connection getConnection() &#123; Connection connection = null; String URL = DATABASE +"?characterEncoding=UTF-8"; try&#123; Class.forName(DRIVER); connection = DriverManager.getConnection(URL,USER,PASSWORD); &#125; catch (ClassNotFoundException | SQLException e) &#123; logger.error(URL + "连接MySQL数据库失败！", e); return null; &#125; return connection; &#125;&#125; 获取ddl语句的实现： 12345678910111213141516171819202122232425262728293031323334public void testDB() &#123; String tableName = "example"; Connection conn = DBUtil.getConnection(); String sql = String.format("SHOW CREATE TABLE %s", tableName);//查询sql //String sql = "SHOW CREATE TABLE ?"; PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); //ps.setString(1, tableName); ResultSet resultSet = ps.executeQuery(); while (resultSet.next()) &#123; System.out.println(resultSet.getString(1));//第一个参数获取的是tableName System.out.println(resultSet.getString(2));//第二个参数获取的是表的ddl语句 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null != ps)&#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(null != conn) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 查询结果: 注意：这里用ps.setString() 会在tableName上加上引号，导致MySQLSyntaxErrorException。 1show create table 'tableName' 1com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;example&apos;&apos; at line 1]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread 源码阅读]]></title>
    <url>%2F2019%2F02%2F21%2FSource%20reading%2FThread%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Thread 源码阅读 123publicclass Thread implements Runnable &#123;&#125; 所有Thread类实现了Runnable接口并实现了run()方法，为什么叫Runnable，而不是Running呢? 那是因为线程是可运行状态，并不表示此时此刻正在运行，线程的运行还需要处理器的调度。 构造方法1234public Thread(ThreadGroup group, Runnable target, String name,long stackSize) &#123;init(group, target, name, stackSize);&#125; 方法currentThread()返回当前执行线程对象的一个引用。 123456/*** Returns a reference to the currently executing thread object.** @return the currently executing thread.*/public static native Thread currentThread(); sleep(long millis)使当前执行的线程睡眠指定的 毫秒。当传入的时间millis为负数时，抛出IllegalArgumentException异常。 1public static native void sleep(long millis) throws InterruptedException; start()使当前线程开始执行。注意：一个已经执行的线程是不能执行start()方法的。 12345678910111213141516171819202122232425262728293031public synchronized void start() &#123; /** * This method is not invoked for the main method thread or "system" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state "NEW". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125; void interrupt()interrupt()中断当前线程的执行。 1234567891011121314public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0();&#125; boolean isInterrupted()检查当前线程是不是被中断。 123public boolean isInterrupted() &#123; return isInterrupted(false); &#125; 线程的优先级123456public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 线程的优先级分为10级，最小优先级为1，最大优先级为10,普通优先级为5. setDaemon(boolean on)如果on = true，则设置当前线程为守护线程。 注意：这个方法必须在线程启动前调用。 1234567public final void setDaemon(boolean on) &#123; checkAccess(); if (isAlive()) &#123; throw new IllegalThreadStateException(); &#125; daemon = on;&#125;]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring Boot继承MyBatis 如何实现多数据源动态加载？]]></title>
    <url>%2F2019%2F02%2F12%2Fjava%2FspringBoot%E7%BB%A7%E6%89%BFMyBatis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在公司的项目中遇到需要根据获取的数据库信息来动态连接数据库，执行SQL语句。通过JDBC很好实现，但是就不能使用MyBatisGenerator生成的SQL代码，需要手动写SQL了。网上能查到的教程都是Mybatis静态连接，或者多个数据源之间来回切换，不符合动态连接数据库的需求。那么如何在MyBatis里面如何实现呢？ 1.首先再resources目录下新建一个jdbc配置文件.1234huiyuan.port=com.mysql.jdbc.Driverusercloud.port=jdbc:mysql://127.0.0.1:3306/***?characterEncoding=UTF-8jdbc.username=rootjdbc.password=admin 2.配置mybatis-config.xml12345678910111213141516171819202122232425&lt;configuration&gt; &lt;properties resource="mybatis/jdbc.properties"/&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name="com.***.pojo"/&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/***/mapper/DataMediaSourceMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.配置工具类关键在第三步，SqlSessionFactoryBuilder根据动态获取的数据库配置信息构建出 SqlSessionFactory 的实例，然后根据SqlSessionFactory 获取SqlSession 的实例 ，然后根据SqlSession 执行已映射的 SQL 语句 。 12345678910111213141516171819202122232425262728293031323334353637383940public class DataSourceConfig &#123; static SqlSession session; public static SqlSession getSession() &#123; return session; &#125; public static void setSession(SqlSession session) &#123; DataSourceConfig.session = session; &#125; /** * 动态获取数据库连接SqlSession * @param database * @param username * @param password * @return */ public static SqlSession getSqlSession(String database, String username, String password) &#123; Properties properties = new Properties(); properties.setProperty("jdbc.driver", "com.mysql.jdbc.Driver"); properties.setProperty("jdbc.url",database +"?characterEncoding=UTF-8"); properties.setProperty("jdbc.username", username); properties.setProperty("jdbc.password", password); String resource = "mybatis/mybatis-config.xml"; Reader reader = null; try &#123; reader = Resources.getResourceAsReader(resource); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(reader,properties); session = factory.openSession(); setSession(session); return session; &#125; &#125; 参考资料http://www.mybatis.org/mybatis-3/zh/getting-started.html]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决不同操作系统下git换行符一致性问题]]></title>
    <url>%2F2018%2F10%2F25%2Fgit%2F%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8Bgit%E6%8D%A2%E8%A1%8C%E7%AC%A6%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决不同操作系统下git换行符一致性问题新的电脑配置环境时，有可能会出现提交代码不能正确增量显示的问题。那么如何一次性解决不同操作系统下git换行符不一致的问题呢？ 一、不同操系统下的换行符CR回车 LF换行 Windows/Dos CRLF \r\n Linux/Unix LF \n MacOS CR \r 二、解决方法打卡git bash，设置core.autocrlf和core.safecrlf（可不设置），建议设置autocrlf为input，safecrlf为true，同时设置你的Eclipse、IDEA等IDE的换行符为LF\n。下面为参数说明，–global表示全局设置 2.1、autocrlf#提交时转换为LF，检出时转换为CRLFgit config --global core.autocrlf true #提交时转换为LF，检出时不转换git config --global core.autocrlf input #提交检出均不转换git config --global core.autocrlf false 2.2、safecrlf#拒绝提交包含混合换行符的文件git config --global core.safecrlf true #允许提交包含混合换行符的文件git config --global core.safecrlf false #提交包含混合换行符的文件时给出警告git config --global core.safecrlf warn]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[之江花园别墅小区 近阿里网易恒生大厦宝龙城]]></title>
    <url>%2F2018%2F10%2F25%2Flife%2F%E4%B9%8B%E6%B1%9F%E8%8A%B1%E5%9B%AD%E5%B0%8F%E5%8C%BA%20%E8%BF%91%E9%98%BF%E9%87%8C%E7%BD%91%E6%98%93%E6%81%92%E7%94%9F%2C%E5%AE%9D%E9%BE%99%E5%9F%8E%E9%99%84%E8%BF%91%2F</url>
    <content type="text"><![CDATA[基本信息时间 ： 2018年11月上旬。位置 ： 杭州市滨江区钱塘江路之江花园小区，近阿里，网易，恒生，三维等。距离地铁4号线联庄站500m内。价格 ： 租金押一付三。2150元一个月，物业费50元一个月，民用水，峰谷电，很划算。 坐标小区： 之江花园小区 距阿里网易4-5公里 距宝龙城，恒生大厦，三维1.5到2公里 小区安保很严，外来人员先核实登记才可以进入。外卖小哥哥在小区送外卖只能走路，不能骑电瓶车，心疼。 设施环境介绍空调、冰箱、洗衣机、太阳能电热水器、电视、浴霸、超大实木衣橱等设施齐全。 客厅有超大电视，华数高清数字电视付了一年，如果后来不看的话可以取消。 有超大的南北通透的客厅，客厅外有两个阳台，背面的阳台朝钱塘江，可以看到江景，看到对面的山，六和塔。 南面的阳台靠近小区，很安静，可以晾衣服，被子，采光很好。 有超大的厨房，周末可以自己diy。厨房的设备一应俱全，油烟机用的是方太的。 网费付了一年。 民用峰谷电，平常5毛多，夜间2毛多。 卧室介绍要出租的是朝南次卧，采光好，朝小区，睡觉很安静。目测大概15-18平，我不是很清楚。设施有实木的超大衣柜，实木的床，木制地板。所有房间，以及客厅都是大金中央空调，两三个空调外机，无论是制冷还是制热都没有任何压力。还有飞利浦的卧室电视，有天猫魔盒，基本上什么都能看，我用的不多，偶尔看看好声音，还有相亲类的节目看着好玩。 卫生间有全自动的太阳能热水器，可以自动上水，下雨的冬天还可以电动加热。 我们住在4楼，楼上有一个阁楼，可以放东西，很方便。 距离钱塘江的樱花跑道很近，出小区100m就到了。基本上晚上吃过饭会去钱塘江或宝龙城溜达一圈，然后回来看电视。 室友介绍两个室友都是阿里的小哥哥，素质很高。平时上班都比较忙，基本上晚上10点前很少回来过，由于我睡得比较早，他们回来的时候我差不都睡了，所以基本上是你一个人住着一套大房子。而且两位都很好相处。 主卧住了一位阿里p7的小哥哥，人很好相处。每个周末都飞回家。主卧有卫生间，阳台。所以得跟另外一位阿里小哥哥共用卫生间，这个小哥哥为人随和，生活很精致，很爱卫生。 租金租金押一付三。2150元一个月，物业费50元一个月，民用水，峰谷电，很划算。 下面是一些周边图片 联系方式感兴趣的可以扫码加微信，备注租房，谢谢。]]></content>
      <categories>
        <category>缤纷生活</category>
      </categories>
      <tags>
        <tag>缤纷生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码解析(JDK7)]]></title>
    <url>%2F2018%2F10%2F24%2FSource%20reading%2FConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88JDK7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap源码解析(JDK7) Constants (常量)12345/** * The default initial capacity for this table, * used when not otherwise specified in a constructor. */static final int DEFAULT_INITIAL_CAPACITY = 16; 默认的最初的容量为16 12345/** * The default load factor for this table, used when not * otherwise specified in a constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f; 默认的负载因子为0.75 12345/** * The default concurrency level for this table, used when not * otherwise specified in a constructor. */static final int DEFAULT_CONCURRENCY_LEVEL = 16; 默认的并发级别为16 1234567/** * The maximum capacity, used if a higher value is implicitly * specified by either of the constructors with arguments. MUST * be a power of two &lt;= 1&lt;&lt;30 to ensure that entries are indexable * using ints. */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 最大容量为2的32次幂。 123456/** * The minimum capacity for per-segment tables. Must be a power * of two, at least two to avoid immediate resizing on next use * after lazy construction. */static final int MIN_SEGMENT_TABLE_CAPACITY = 2; 最小的段数。 12345/** * The maximum number of segments to allow; used to bound * constructor arguments. Must be power of two less than 1 &lt;&lt; 24. */static final int MAX_SEGMENTS = 1 &lt;&lt; 16; // slightly conservative 略微保守的最大段数为2的16次幂。 1234567/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */static final int RETRIES_BEFORE_LOCK = 2; 字段(Fields)12345678910111213/** * A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. */private transient final int hashSeed = randomHashSeed(this);private static int randomHashSeed(ConcurrentHashMap instance) &#123; if (sun.misc.VM.isBooted() &amp;&amp; Holder.ALTERNATIVE_HASHING) &#123; return sun.misc.Hashing.randomHashSeed(instance); &#125; return 0;&#125; transient: 用transient关键字标记的成员变量不参与序列化过程。]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 源码解析(JDK1.7)]]></title>
    <url>%2F2018%2F10%2F23%2FSource%20reading%2FArrayList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK7)%2F</url>
    <content type="text"><![CDATA[ArrayList 源码解析(JDK1.7)包含的方法如下图： 所有方法按照字母a-z排序 属性DEFAULT_CAPACITY1234/** * 默认的初始容量 */private static final int DEFAULT_CAPACITY = 10; list的默认初始容量。 EMPTY_ELEMENTDATA1234/** * Shared empty array instance used for empty instances.空的对象数组 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 空的数组对象。 elementData1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == EMPTY_ELEMENTDATA will be expanded to * DEFAULT_CAPACITY when the first element is added. */private transient Object[] elementData; 当插入第一个元素的时候，空的list的容量将会从0扩展到10. size123456/** * The size of the ArrayList (the number of elements it contains). * 数组的大小 * @serial */ private int size; 数组中含有的元素的个数。 构造函数ArrayList(int initialCapacity)1234567891011121314/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity];&#125; 构造一个带有指定大小容量的list, 如果入参小于0的话则抛出IllegalArgumentException不合法的参数异常。 ArrayList()1234567/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA;&#125; 构造一个带有初始容量为10的空list。 ArrayList(Collection&lt;? extends E&gt; c)123456789101112131415/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 构造一个list包含指定容器的元素，其中的元素顺序按照容器的遍历顺序。 trimToSize()1234567891011/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = Arrays.copyOf(elementData, size); &#125;&#125; 将当前ArrayList的实例的容量调整为当前含有的元素的个数。 这个方法可以节省存储空间。 ensureCapacity(int minCapacity)1234567891011121314151617181920 /** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; //如果数组为空，minExpand容量取0，否则取默认值10 int minExpand = (elementData != EMPTY_ELEMENTDATA) // any size if real element table ? 0 // larger than default for empty table. It's already supposed to be // at default size. : DEFAULT_CAPACITY;//如果minCapacity大于minExpand,则设为最小容量 if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; size()12345678/** * Returns the number of elements in this list. * * @return the number of elements in this list */public int size() &#123; return size;&#125; 返回当前list中所含元素的个数。 isEmpty()12345678/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements */public boolean isEmpty() &#123; return size == 0;&#125; 作用：判断当前list是否为空。 如果list中所含元素个数为0的话，表示为空，返回true，否则返回false。 contains(Object o)123456789101112/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains * at least one element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this list is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 作用：判断当前list是否包含指定元素。 如果包含则返回true，不包含则返回false。 indexOf(Object o)1234567891011121314151617181920/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int indexOf(Object o) &#123; //如果对象为空的话 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 返回元素在list中的第一个索引。 lastIndexOf(Object o)12345678910111213141516171819/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 返回数组list里面匹配的最后一个元素。 clone()123456789101112131415161718/** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */public Object clone() &#123; try &#123; @SuppressWarnings("unchecked") ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; //将修改次数计数器置位0 return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125;&#125; 浅拷贝：只复制当前对象，对该对象内部的引用不能复制。 深拷贝：对对象内部的引用均复制，是创建一个新的实例，并复制实例。 返回当前数组list实例的浅拷贝(元素本身不复制)。 toArray()1234567891011121314151617/** * Returns an array containing all of the elements in this list * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be "safe" in that no references to it are * maintained by this list. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this list in * proper sequence */public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; 以合适的顺序（从第一个到最后一个元素）返回当前list中的所有元素到一个数组 返回一个数组，这个数组包含当前list的所有元素，并且以从第一个到最后一个元素的顺序。 toArray(T[] a)get(int index)123456789101112/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; rangeCheck(index); //对index进行检查，是否超出了边界 return elementData(index);&#125; 返回指定位置上的元素。]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object源码解析(JDK1.8)]]></title>
    <url>%2F2018%2F10%2F21%2FSource%20reading%2FObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8)%2F</url>
    <content type="text"><![CDATA[Object源码解析(JDK1.8)Object类是Java中所有类的基类，在编译时会自动导入，位于java.lang包中，而Object中具有的属性和行为，是Java语言设计背后的思维体现。这里写的代码是JDK8中的，其他版本的JDK可能略有不同。 包含的方法如下图： 所有方法按照字母a-z排序 Object类方法说明： Object类中的方法大部分都是native方法（如上图中方法前有一个绿色的实心小圆圈，圆圈的右上角有大写字母N，表示该方法是一个native方法），用此关键字修饰的方法是java中的本地方法，一般都是用C/C++语言实现的。 构造方法Object类中没有显示的提供构造方法，是编译器默认提供的。 registerNatives()方法1234private static native void registerNatives(); static &#123; registerNatives(); &#125; registerNatives()是一个本地方法，具体是用C/C++在DLL中实现的，在类加载的时候执行。 getClass()方法1234567891011121314151617181920/** * Returns the runtime class of this &#123;@code Object&#125;. The returned * &#123;@code Class&#125; object is the object that is locked by &#123;@code * static synchronized&#125; methods of the represented class. * * &lt;p&gt;&lt;b&gt;The actual result type is &#123;@code Class&lt;? extends |X|&gt;&#125; * where &#123;@code |X|&#125; is the erasure of the static type of the * expression on which &#123;@code getClass&#125; is called.&lt;/b&gt; For * example, no cast is required in this code fragment:&lt;/p&gt; * * &lt;p&gt; * &#123;@code Number n = 0; &#125;&lt;br&gt; * &#123;@code Class&lt;? extends Number&gt; c = n.getClass(); &#125; * &lt;/p&gt; * * @return The &#123;@code Class&#125; object that represents the runtime * class of this object. * @jls 15.8.2 Class Literals */public final native Class&lt;?&gt; getClass(); 返回当前对象运行时的类，final关键字修饰说明这个方法不能被子类重写。 hashcode()方法123456789101112131415161718192021222324252627282930313233343536/** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * &#123;@link java.util.HashMap&#125;. * &lt;p&gt; * The general contract of &#123;@code hashCode&#125; is: * &lt;ul&gt; * &lt;li&gt;Whenever it is invoked on the same object more than once during * an execution of a Java application, the &#123;@code hashCode&#125; method * must consistently return the same integer, provided no information * used in &#123;@code equals&#125; comparisons on the object is modified. * This integer need not remain consistent from one execution of an * application to another execution of the same application. * &lt;li&gt;If two objects are equal according to the &#123;@code equals(Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of * the two objects must produce the same integer result. * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal * according to the &#123;@link java.lang.Object#equals(java.lang.Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of the * two objects must produce distinct integer results. However, the * programmer should be aware that producing distinct integer results * for unequal objects may improve the performance of hash tables. * &lt;/ul&gt; * &lt;p&gt; * As much as is reasonably practical, the hashCode method defined by * class &#123;@code Object&#125; does return distinct integers for distinct * objects. (This is typically implemented by converting the internal * address of the object into an integer, but this implementation * technique is not required by the * Java&amp;trade; programming language.) * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */public native int hashCode(); Object类中的hashcode()方法用来鉴定两个对象是否相等，返回对象在内存中地址转换成的一个 int类型的值。如果没有重写hashcode()方法，任何对象的hashcode()方法都是不相等的。 equals()方法入参：Object 返回值：Boolean类型， 123456789101112131415161718192021222324/** * Indicates whether some other object is "equal to" this one. * &lt;p&gt; * The &#123;@code equals&#125; method for class &#123;@code Object&#125; implements * the most discriminating possible equivalence relation on objects; * that is, for any non-null reference values &#123;@code x&#125; and * &#123;@code y&#125;, this method returns &#123;@code true&#125; if and only * if &#123;@code x&#125; and &#123;@code y&#125; refer to the same object * (&#123;@code x == y&#125; has the value &#123;@code true&#125;). * &lt;p&gt; * Note that it is generally necessary to override the &#123;@code hashCode&#125; * method whenever this method is overridden, so as to maintain the * general contract for the &#123;@code hashCode&#125; method, which states * that equal objects must have equal hash codes. * * @param obj the reference object with which to compare. * @return &#123;@code true&#125; if this object is the same as the obj * argument; &#123;@code false&#125; otherwise. * @see #hashCode() * @see java.util.HashMap */public boolean equals(Object obj) &#123; return (this == obj);&#125; Object类中的equals()方法用来判断两个对象是否相等。如果当前对象与传入的对象相同，则返回true，否则返回false。 注意：这个equals()方法没有被final关键字修饰，也就是说可以被子类重写，比如说String类型里面重写了equals()方法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Compares this string to the specified object. The result is &#123;@code * true&#125; if and only if the argument is not &#123;@code null&#125; and is a &#123;@code * String&#125; object that represents the same sequence of characters as this * object. * * @param anObject * The object to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if the given object represents a &#123;@code String&#125; * equivalent to this string, &#123;@code false&#125; otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */public boolean equals(Object anObject) &#123; //如果对象相等的话，直接返回true if (this == anObject) &#123; return true; &#125; /** * 如果对象不相同，则比较String中的value值是否相同。 * 首先判断传入的对象是不是String类型的实例： * 如果是，将字符串转换成字符数组接着逐一比较数组里的字符是否相同，如果不同，直接返回false。 * 遍历结束，则表示相同，返回true。 * */ if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 如果传入的对象和当前对象是同一个对象，返回true；如果传入的对象是String类型的实例，则判断传入对象的String和当前String是否相等，如果相等，则返回true，否则返回false。 instanceof关键字的作用：判断左边的对象是否是右边类的实例，例如 objectA.instanceof(ClassB)判断对象A是否是类B的实例，如果是则返回true，否则返回false。 clone()方法1234567891011/** * Creates and returns a copy of this object. * @return a clone of this instance. * @throws CloneNotSupportedException if the object's class does not * support the &#123;@code Cloneable&#125; interface. Subclasses * that override the &#123;@code clone&#125; method can also * throw this exception to indicate that an instance cannot * be cloned. * @see java.lang.Cloneable */protected native Object clone() throws CloneNotSupportedException; 返回当前实例的克隆对象。 toString()方法123456789101112131415161718192021222324/** * Returns a string representation of the object. In general, the * &#123;@code toString&#125; method returns a string that * "textually represents" this object. The result should * be a concise but informative representation that is easy for a * person to read. * It is recommended that all subclasses override this method. * &lt;p&gt; * The &#123;@code toString&#125; method for class &#123;@code Object&#125; * returns a string consisting of the name of the class of which the * object is an instance, the at-sign character `&#123;@code @&#125;', and * the unsigned hexadecimal representation of the hash code of the * object. In other words, this method returns a string equal to the * value of: * &lt;blockquote&gt; * &lt;pre&gt; * getClass().getName() + '@' + Integer.toHexString(hashCode()) * &lt;/pre&gt;&lt;/blockquote&gt; * * @return a string representation of the object. */public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; 返回表示当前对象的字符串，字符串的形式是类名@hashCode的十六进制表示，比如objectA是classB的实例，ObjectA的hashCode为c,而c的十六进制为d,则调用ObjectA的toString()方法返回ClassB@d。推荐所有的子类都重写这个方法。 notify()方法123456789101112131415161718192021222324252627282930313233/** * Wakes up a single thread that is waiting on this object's * monitor. If any threads are waiting on this object, one of them * is chosen to be awakened. The choice is arbitrary and occurs at * the discretion of the implementation. A thread waits on an object's * monitor by calling one of the &#123;@code wait&#125; methods. * &lt;p&gt; * The awakened thread will not be able to proceed until the current * thread relinquishes the lock on this object. The awakened thread will * compete in the usual manner with any other threads that might be * actively competing to synchronize on this object; for example, the * awakened thread enjoys no reliable privilege or disadvantage in being * the next thread to lock this object. * &lt;p&gt; * This method should only be called by a thread that is the owner * of this object's monitor. A thread becomes the owner of the * object's monitor in one of three ways: * &lt;ul&gt; * &lt;li&gt;By executing a synchronized instance method of that object. * &lt;li&gt;By executing the body of a &#123;@code synchronized&#125; statement * that synchronizes on the object. * &lt;li&gt;For objects of type &#123;@code Class,&#125; by executing a * synchronized static method of that class. * &lt;/ul&gt; * &lt;p&gt; * Only one thread at a time can own an object's monitor. * * @throws IllegalMonitorStateException if the current thread is not * the owner of this object's monitor. * @see java.lang.Object#notifyAll() * @see java.lang.Object#wait() */public final native void notify(); 唤醒在该对象监视器(Monitor)里等待的一个线程。 notifyAll()方法1234567891011121314151617181920212223/** * Wakes up all threads that are waiting on this object's monitor. A * thread waits on an object's monitor by calling one of the * &#123;@code wait&#125; methods. * &lt;p&gt; * The awakened threads will not be able to proceed until the current * thread relinquishes the lock on this object. The awakened threads * will compete in the usual manner with any other threads that might * be actively competing to synchronize on this object; for example, * the awakened threads enjoy no reliable privilege or disadvantage in * being the next thread to lock this object. * &lt;p&gt; * This method should only be called by a thread that is the owner * of this object's monitor. See the &#123;@code notify&#125; method for a * description of the ways in which a thread can become the owner of * a monitor. * * @throws IllegalMonitorStateException if the current thread is not * the owner of this object's monitor. * @see java.lang.Object#notify() * @see java.lang.Object#wait() */public final native void notifyAll(); 唤醒当前对象监视器下的所有线程。 wait(long)方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Causes the current thread to wait until either another thread invokes the * &#123;@link java.lang.Object#notify()&#125; method or the * &#123;@link java.lang.Object#notifyAll()&#125; method for this object, or a * specified amount of time has elapsed. * &lt;p&gt; * The current thread must own this object's monitor. * &lt;p&gt; * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to * place itself in the wait set for this object and then to relinquish * any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt; * becomes disabled for thread scheduling purposes and lies dormant * until one of four things happens: * &lt;ul&gt; * &lt;li&gt;Some other thread invokes the &#123;@code notify&#125; method for this * object and thread &lt;var&gt;T&lt;/var&gt; happens to be arbitrarily chosen as * the thread to be awakened. * &lt;li&gt;Some other thread invokes the &#123;@code notifyAll&#125; method for this * object. * &lt;li&gt;Some other thread &#123;@linkplain Thread#interrupt() interrupts&#125; * thread &lt;var&gt;T&lt;/var&gt;. * &lt;li&gt;The specified amount of real time has elapsed, more or less. If * &#123;@code timeout&#125; is zero, however, then real time is not taken into * consideration and the thread simply waits until notified. * &lt;/ul&gt; * The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this * object and re-enabled for thread scheduling. It then competes in the * usual manner with other threads for the right to synchronize on the * object; once it has gained control of the object, all its * synchronization claims on the object are restored to the status quo * ante - that is, to the situation as of the time that the &#123;@code wait&#125; * method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the * invocation of the &#123;@code wait&#125; method. Thus, on return from the * &#123;@code wait&#125; method, the synchronization state of the object and of * thread &#123;@code T&#125; is exactly as it was when the &#123;@code wait&#125; method * was invoked. * &lt;p&gt; * A thread can also wake up without being notified, interrupted, or * timing out, a so-called &lt;i&gt;spurious wakeup&lt;/i&gt;. While this will rarely * occur in practice, applications must guard against it by testing for * the condition that should have caused the thread to be awakened, and * continuing to wait if the condition is not satisfied. In other words, * waits should always occur in loops, like this one: * &lt;pre&gt; * synchronized (obj) &#123; * while (&amp;lt;condition does not hold&amp;gt;) * obj.wait(timeout); * ... // Perform action appropriate to condition * &#125; * &lt;/pre&gt; * (For more information on this topic, see Section 3.2.3 in Doug Lea's * "Concurrent Programming in Java (Second Edition)" (Addison-Wesley, * 2000), or Item 50 in Joshua Bloch's "Effective Java Programming * Language Guide" (Addison-Wesley, 2001). * * &lt;p&gt;If the current thread is &#123;@linkplain java.lang.Thread#interrupt() * interrupted&#125; by any thread before or while it is waiting, then an * &#123;@code InterruptedException&#125; is thrown. This exception is not * thrown until the lock status of this object has been restored as * described above. * * &lt;p&gt; * Note that the &#123;@code wait&#125; method, as it places the current thread * into the wait set for this object, unlocks only this object; any * other objects on which the current thread may be synchronized remain * locked while the thread waits. * &lt;p&gt; * This method should only be called by a thread that is the owner * of this object's monitor. See the &#123;@code notify&#125; method for a * description of the ways in which a thread can become the owner of * a monitor. * * @param timeout the maximum time to wait in milliseconds. * @throws IllegalArgumentException if the value of timeout is * negative. * @throws IllegalMonitorStateException if the current thread is not * the owner of the object's monitor. * @throws InterruptedException if any thread interrupted the * current thread before or while the current thread * was waiting for a notification. The &lt;i&gt;interrupted * status&lt;/i&gt; of the current thread is cleared when * this exception is thrown. * @see java.lang.Object#notify() * @see java.lang.Object#notifyAll() */public final native void wait(long timeout) throws InterruptedException; 使当前线程等待直到另外一个线程调用等待线程的notify()方法或者notifyAll()方法，或者等待指定的时间。 wait(long,int)方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * Causes the current thread to wait until another thread invokes the * &#123;@link java.lang.Object#notify()&#125; method or the * &#123;@link java.lang.Object#notifyAll()&#125; method for this object, or * some other thread interrupts the current thread, or a certain * amount of real time has elapsed. * &lt;p&gt; * This method is similar to the &#123;@code wait&#125; method of one * argument, but it allows finer control over the amount of time to * wait for a notification before giving up. The amount of real time, * measured in nanoseconds, is given by: * &lt;blockquote&gt; * &lt;pre&gt; * 1000000*timeout+nanos&lt;/pre&gt;&lt;/blockquote&gt; * &lt;p&gt; * In all other respects, this method does the same thing as the * method &#123;@link #wait(long)&#125; of one argument. In particular, * &#123;@code wait(0, 0)&#125; means the same thing as &#123;@code wait(0)&#125;. * &lt;p&gt; * The current thread must own this object's monitor. The thread * releases ownership of this monitor and waits until either of the * following two conditions has occurred: * &lt;ul&gt; * &lt;li&gt;Another thread notifies threads waiting on this object's monitor * to wake up either through a call to the &#123;@code notify&#125; method * or the &#123;@code notifyAll&#125; method. * &lt;li&gt;The timeout period, specified by &#123;@code timeout&#125; * milliseconds plus &#123;@code nanos&#125; nanoseconds arguments, has * elapsed. * &lt;/ul&gt; * &lt;p&gt; * The thread then waits until it can re-obtain ownership of the * monitor and resumes execution. * &lt;p&gt; * As in the one argument version, interrupts and spurious wakeups are * possible, and this method should always be used in a loop: * &lt;pre&gt; * synchronized (obj) &#123; * while (&amp;lt;condition does not hold&amp;gt;) * obj.wait(timeout, nanos); * ... // Perform action appropriate to condition * &#125; * &lt;/pre&gt; * This method should only be called by a thread that is the owner * of this object's monitor. See the &#123;@code notify&#125; method for a * description of the ways in which a thread can become the owner of * a monitor. * * @param timeout the maximum time to wait in milliseconds. * @param nanos additional time, in nanoseconds range * 0-999999. * @throws IllegalArgumentException if the value of timeout is * negative or the value of nanos is * not in the range 0-999999. * @throws IllegalMonitorStateException if the current thread is not * the owner of this object's monitor. * @throws InterruptedException if any thread interrupted the * current thread before or while the current thread * was waiting for a notification. The &lt;i&gt;interrupted * status&lt;/i&gt; of the current thread is cleared when * this exception is thrown. */public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout);&#125; 和只有一个入参的wait(long)方法类似，但它允许更精细的时间控制，以纳秒进行实时的统计。 wait()方法1234567891011121314151617181920212223242526272829303132333435363738394041/** * Causes the current thread to wait until another thread invokes the * &#123;@link java.lang.Object#notify()&#125; method or the * &#123;@link java.lang.Object#notifyAll()&#125; method for this object. * In other words, this method behaves exactly as if it simply * performs the call &#123;@code wait(0)&#125;. * &lt;p&gt; * The current thread must own this object's monitor. The thread * releases ownership of this monitor and waits until another thread * notifies threads waiting on this object's monitor to wake up * either through a call to the &#123;@code notify&#125; method or the * &#123;@code notifyAll&#125; method. The thread then waits until it can * re-obtain ownership of the monitor and resumes execution. * &lt;p&gt; * As in the one argument version, interrupts and spurious wakeups are * possible, and this method should always be used in a loop: * &lt;pre&gt; * synchronized (obj) &#123; * while (&amp;lt;condition does not hold&amp;gt;) * obj.wait(); * ... // Perform action appropriate to condition * &#125; * &lt;/pre&gt; * This method should only be called by a thread that is the owner * of this object's monitor. See the &#123;@code notify&#125; method for a * description of the ways in which a thread can become the owner of * a monitor. * * @throws IllegalMonitorStateException if the current thread is not * the owner of the object's monitor. * @throws InterruptedException if any thread interrupted the * current thread before or while the current thread * was waiting for a notification. The &lt;i&gt;interrupted * status&lt;/i&gt; of the current thread is cleared when * this exception is thrown. * @see java.lang.Object#notify() * @see java.lang.Object#notifyAll() */public final void wait() throws InterruptedException &#123; wait(0);&#125; finalize()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Called by the garbage collector on an object when garbage collection * determines that there are no more references to the object. * A subclass overrides the &#123;@code finalize&#125; method to dispose of * system resources or to perform other cleanup. * &lt;p&gt; * The general contract of &#123;@code finalize&#125; is that it is invoked * if and when the Java&amp;trade; virtual * machine has determined that there is no longer any * means by which this object can be accessed by any thread that has * not yet died, except as a result of an action taken by the * finalization of some other object or class which is ready to be * finalized. The &#123;@code finalize&#125; method may take any action, including * making this object available again to other threads; the usual purpose * of &#123;@code finalize&#125;, however, is to perform cleanup actions before * the object is irrevocably discarded. For example, the finalize method * for an object that represents an input/output connection might perform * explicit I/O transactions to break the connection before the object is * permanently discarded. * &lt;p&gt; * The &#123;@code finalize&#125; method of class &#123;@code Object&#125; performs no * special action; it simply returns normally. Subclasses of * &#123;@code Object&#125; may override this definition. * &lt;p&gt; * The Java programming language does not guarantee which thread will * invoke the &#123;@code finalize&#125; method for any given object. It is * guaranteed, however, that the thread that invokes finalize will not * be holding any user-visible synchronization locks when finalize is * invoked. If an uncaught exception is thrown by the finalize method, * the exception is ignored and finalization of that object terminates. * &lt;p&gt; * After the &#123;@code finalize&#125; method has been invoked for an object, no * further action is taken until the Java virtual machine has again * determined that there is no longer any means by which this object can * be accessed by any thread that has not yet died, including possible * actions by other objects or classes which are ready to be finalized, * at which point the object may be discarded. * &lt;p&gt; * The &#123;@code finalize&#125; method is never invoked more than once by a Java * virtual machine for any given object. * &lt;p&gt; * Any exception thrown by the &#123;@code finalize&#125; method causes * the finalization of this object to be halted, but is otherwise * ignored. * * @throws Throwable the &#123;@code Exception&#125; raised by this method * @see java.lang.ref.WeakReference * @see java.lang.ref.PhantomReference * @jls 12.6 Finalization of Class Instances */protected void finalize() throws Throwable &#123; &#125; JAVA内存回收机制是通过根节点到当前对象之间有没有一条引用链指向来判断对象是否可以回收的。 该对象没有引用指向的时候，垃圾收集器在合适的时机调用该对象的finalize()方法对该对象进行回收。 参考资料 https://blog.csdn.net/benjaminlee1/article/details/72843713]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>缤纷生活</category>
      </categories>
      <tags>
        <tag>缤纷生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2018%2F07%2F14%2Fdesign%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式工厂模式属于创建型模式，提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时，不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 介绍意图：定义一个创建对象的接口，让子类决定实例化哪一个工厂类。 主要解决：接口选择问题 如何解决：子类实现工厂接口，返回抽象产品 使用场景：设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 实现我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。FactoryPatternDemo*，我们的演示类使用 *ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 创建一个接口 1234public interface Shape &#123; void draw();&#125; 创建实现接口的实体类 12345678public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; 12345678public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; 12345678public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 创建一个工厂，生成基于给定信息的实体类的对象。 123456789101112131415161718public class ShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125;&#125; 使用该工厂，通过传递类型信息来获取实体类的对象。 12345678910111213141516171819202122232425public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape("CIRCLE"); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape("RECTANGLE"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape("SQUARE"); //调用 Square 的 draw 方法 shape3.draw(); &#125;&#125; 执行程序，输出结果。 123Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method. 参考资料https://www.runoob.com/design-pattern/design-pattern-tutorial.html]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F07%2F07%2Fdesign%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 介绍意图：保证一个类只有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁的被创建和销毁。 关键代码：构造函数私有化。 优点：在内存里只有一个实例，减小了对内存的开销。 缺点：没有接口，不能继承，与单一职责冲突，一个类只关心内部逻辑，而不关心外面怎么实现它。 使用场景： 要求生产序列号唯一 web中的计数器，不想每次刷新都在数据库中加一次，用单例模式先缓存起来。 创建一个对象需要消耗的资源过多，比如I/O与数据库的连接等。 实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。 SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo*，我们的演示类使用 *SingleObject 类来获取 SingleObject 对象。 创建一个Singleton类 123456789101112131415161718public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println("Hello World!"); &#125;&#125; 从Singleton类获取唯一个对象。 1234567891011121314public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125; 执行程序，输出结果： 1Hello World! 单例模式的几种实现方式一、懒汉式，线程不安全是否lazy初始化： 是 是否多线程安全：否 实现难度：容易 描述：这种方式是最进本的实现方式，最大的问题是不支持多线程。因为没有加synchronized，当多线程访问的时候，可能同时创建多个实例，所以从多线程上来看，并不算作单例模式。 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 123456789101112public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。 二、懒汉式，线程安全是否lazy初始化：是 是否线程安全：是 实现难度：容易 描述：具备很好的lazy loading, 多线程安全，但是效率低下。 优点：懒加载，避免内存浪费。 缺点： 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 三、饿汉式是否lazy初始化：否 是否多线程安全：是 实现难度：容易 描述：这种方法比较常用，但是容易产生垃圾对象。 优点：没有加锁，执行效率高。 缺点：类加载时就初始化，浪费内存。 12345678public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 四、双检锁/双重校验锁（DCL，即 double-checked locking）是否lazy初始化：是 是否多线程安全：是 实现难度：较复杂 描述：这种方式线程安全，且在多线程的情况下，能保证高性能。 123456789101112131415public class Singleton &#123; private volatile static Singleton singleton; //多线程访问情形下，阻止编译器自动优化。 private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (null == singleton) &#123; synchronized (Singleton.class) &#123; if (null == singleton) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 参考资料https://www.runoob.com/design-pattern/design-pattern-tutorial.html]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F07%2F02%2Fdesign%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[​ 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式的分类有以上思维导图可以看出，设计模式可以分为创建型，结构型和行为型模式。 设计模式的六大原则开闭原则解释：对扩展开放，对修改封闭。 作用：使程序的扩展性好，易于维护和升级。 实现：使用接口和抽象类。 李氏替换任何基类可以出现的地方，子类一定可以出现。 作用：复用基类 依赖倒置面向接口编程，依赖于抽象，而不是依赖于具体。 接口隔离使用多个隔离的接口，比使用单个接口好。 作用：降低依赖，解耦。 迪米特法则一个实体类应该j尽量少的与其他实体类之间互相作用，使系统的各功能模块相对独立。 合成复用原则尽量使用组合，聚合的方式，避免使用继承。]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
</search>
