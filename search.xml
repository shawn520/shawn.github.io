<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA如何实现原子操作？]]></title>
    <url>%2F2019%2F07%2F10%2FJAVA%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[java可以通过锁和循环CAS的方式实现原子操作。下面介绍循环CAS的方式。 循环CAS实现原子操作循环CAS的基本思路就是通过循环执行CAS操作，直到执行成功跳出循环。以下代码实现基于CAS线程安全的计数器方法safeCount()和非线程安全计数器count。初始化100个线程，每个线程执行1w次计数,线程安全的结果应该是100w,而非线程安全的结果可能会小于这个数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Counter &#123; private AtomicInteger atomicI = new AtomicInteger(0); private int i = 0; public static void main(String[] args) &#123; final Counter cas = new Counter(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(600); long start = System.currentTimeMillis(); //初始化100个线程，每个线程执行1w次计数 for(int j=0; j&lt;100; j++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i=0; i&lt;10000; i++)&#123; cas.safeCount(); cas.count(); &#125; &#125; &#125;); threads.add(thread); &#125; for (Thread thread : threads) &#123; thread.start(); &#125; //等待所有线程执行完成 for(Thread thread : threads) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //非线程安全的结果:&lt;100w System.out.println(cas.i); //线程安全的结果: 100w System.out.println(cas.atomicI.get()); System.out.println(System.currentTimeMillis() - start); &#125; /** * 使用CAS实现线程安全计数 */ private void safeCount() &#123; //自旋CAS,直到成功跳出循环 for(;;) &#123; int i = atomicI.get(); boolean suc = atomicI.compareAndSet(i, ++i); if (suc) &#123; break; &#125; &#125; &#125; /** * 非线程安全计数 */ private void count() &#123; i++; &#125;&#125; CAS实现原子操作的问题循环CAS存在三大问题：ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作。 ABA问题什么是ABA问题？如果一个值原来是A，变成了B，又变成了A。那么CAS认为值没有发生变化，实际上是发生了变化的。 解决思路：在变量前面追加版本号A -&gt; B -&gt; A就会变成1A -&gt; 2B -&gt; 3A 这里是完整的 代码。 参考资料：方腾飞《Java并发编程的艺术》]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web项目如何获取表的ddl信息？]]></title>
    <url>%2F2019%2F04%2F04%2FJava%20Web%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%A1%A8%E7%9A%84ddl%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[背景：公司项目是做MySQL数据向同构和异构数据库同步和消息订阅的。在做向消息中间件RMQ同步时，需要根据源表的表信息，在目标数据库创建一个相同的逻辑表。 如果是用shell的话：show create table tableName就可以搞定啦。这里一共有两个参数，第一个是table，第二个是create Table, 我们需要的就是create Table的建表语句。但是这个用Java怎么实现呢？ Mybatis这块暂且还不知道怎么实现，先通过jdbc来实现查询表的ddl语句。思路一：通过执行show create table tableName思路二：show create table tablename 和show databases 可能查的是MySQL的数据库information_schema。 123SELECT * FROM information_schema.columns where TABLE_SCHEMA = "test" AND TABLE_NAME = "example" LIMIT 10;SELECT * FROM information_schema.tables where TABLE_SCHEMA = "test" AND TABLE_NAME = "example" LIMIT 10; 可以根据以上等信息去组装ddl语句，比较复杂，而且账号的权限不一定够。所以这里按思路一的方式。首先是数据库的连接： 123456789101112131415161718192021public class DBUtil &#123; static final Logger logger = LoggerFactory.getLogger(DBUtil.class); private static final String DRIVER = "com.mysql.jdbc.Driver"; private static final String USER = "root"; private static final String PASSWORD = "admin"; private static final String DATABASE = "jdbc:mysql://127.0.0.1:3306/TEST"; public static Connection getConnection() &#123; Connection connection = null; String URL = DATABASE +"?characterEncoding=UTF-8"; try&#123; Class.forName(DRIVER); connection = DriverManager.getConnection(URL,USER,PASSWORD); &#125; catch (ClassNotFoundException | SQLException e) &#123; logger.error(URL + "连接MySQL数据库失败！", e); return null; &#125; return connection; &#125;&#125; 获取ddl语句的实现： 12345678910111213141516171819202122232425262728293031323334public void testDB() &#123; String tableName = "example"; Connection conn = DBUtil.getConnection(); String sql = String.format("SHOW CREATE TABLE %s", tableName);//查询sql //String sql = "SHOW CREATE TABLE ?"; PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); //ps.setString(1, tableName); ResultSet resultSet = ps.executeQuery(); while (resultSet.next()) &#123; System.out.println(resultSet.getString(1));//第一个参数获取的是tableName System.out.println(resultSet.getString(2));//第二个参数获取的是表的ddl语句 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null != ps)&#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(null != conn) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 查询结果: 注意：这里用ps.setString() 会在tableName上加上引号，导致MySQLSyntaxErrorException。 1show create table 'tableName' 1com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;example&apos;&apos; at line 1]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread 源码阅读]]></title>
    <url>%2F2019%2F02%2F21%2FThread%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Thread 源码阅读 123publicclass Thread implements Runnable &#123;&#125; 所有Thread类实现了Runnable接口并实现了run()方法，为什么叫Runnable，而不是Running呢? 那是因为线程是可运行状态，并不表示此时此刻正在运行，线程的运行还需要处理器的调度。 构造方法1234public Thread(ThreadGroup group, Runnable target, String name,long stackSize) &#123;init(group, target, name, stackSize);&#125; 方法currentThread()返回当前执行线程对象的一个引用。 123456/*** Returns a reference to the currently executing thread object.** @return the currently executing thread.*/public static native Thread currentThread(); sleep(long millis)使当前执行的线程睡眠指定的 毫秒。当传入的时间millis为负数时，抛出IllegalArgumentException异常。 1public static native void sleep(long millis) throws InterruptedException; start()使当前线程开始执行。注意：一个已经执行的线程是不能执行start()方法的。 12345678910111213141516171819202122232425262728293031public synchronized void start() &#123; /** * This method is not invoked for the main method thread or "system" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state "NEW". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125; void interrupt()interrupt()中断当前线程的执行。 1234567891011121314public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0();&#125; boolean isInterrupted()检查当前线程是不是被中断。 123public boolean isInterrupted() &#123; return isInterrupted(false); &#125; 线程的优先级123456public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 线程的优先级分为10级，最小优先级为1，最大优先级为10,普通优先级为5. setDaemon(boolean on)如果on = true，则设置当前线程为守护线程。 注意：这个方法必须在线程启动前调用。 1234567public final void setDaemon(boolean on) &#123; checkAccess(); if (isAlive()) &#123; throw new IllegalThreadStateException(); &#125; daemon = on;&#125;]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码解析(JDK7)]]></title>
    <url>%2F2018%2F10%2F24%2FConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88JDK7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap源码解析(JDK7) Constants (常量)12345/** * The default initial capacity for this table, * used when not otherwise specified in a constructor. */static final int DEFAULT_INITIAL_CAPACITY = 16; 默认的最初的容量为16 12345/** * The default load factor for this table, used when not * otherwise specified in a constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f; 默认的负载因子为0.75 12345/** * The default concurrency level for this table, used when not * otherwise specified in a constructor. */static final int DEFAULT_CONCURRENCY_LEVEL = 16; 默认的并发级别为16 1234567/** * The maximum capacity, used if a higher value is implicitly * specified by either of the constructors with arguments. MUST * be a power of two &lt;= 1&lt;&lt;30 to ensure that entries are indexable * using ints. */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 最大容量为2的32次幂。 123456/** * The minimum capacity for per-segment tables. Must be a power * of two, at least two to avoid immediate resizing on next use * after lazy construction. */static final int MIN_SEGMENT_TABLE_CAPACITY = 2; 最小的段数。 12345/** * The maximum number of segments to allow; used to bound * constructor arguments. Must be power of two less than 1 &lt;&lt; 24. */static final int MAX_SEGMENTS = 1 &lt;&lt; 16; // slightly conservative 略微保守的最大段数为2的16次幂。 1234567/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */static final int RETRIES_BEFORE_LOCK = 2; 字段(Fields)12345678910111213/** * A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. */private transient final int hashSeed = randomHashSeed(this);private static int randomHashSeed(ConcurrentHashMap instance) &#123; if (sun.misc.VM.isBooted() &amp;&amp; Holder.ALTERNATIVE_HASHING) &#123; return sun.misc.Hashing.randomHashSeed(instance); &#125; return 0;&#125; transient: 用transient关键字标记的成员变量不参与序列化过程。]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 源码解析(JDK1.7)]]></title>
    <url>%2F2018%2F10%2F23%2FArrayList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK7)%2F</url>
    <content type="text"><![CDATA[ArrayList 源码解析(JDK1.7)包含的方法如下图： 所有方法按照字母a-z排序 属性DEFAULT_CAPACITY1234/** * 默认的初始容量 */private static final int DEFAULT_CAPACITY = 10; list的默认初始容量。 EMPTY_ELEMENTDATA1234/** * Shared empty array instance used for empty instances.空的对象数组 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 空的数组对象。 elementData1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == EMPTY_ELEMENTDATA will be expanded to * DEFAULT_CAPACITY when the first element is added. */private transient Object[] elementData; 当插入第一个元素的时候，空的list的容量将会从0扩展到10. size123456/** * The size of the ArrayList (the number of elements it contains). * 数组的大小 * @serial */ private int size; 数组中含有的元素的个数。 构造函数ArrayList(int initialCapacity)1234567891011121314/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity];&#125; 构造一个带有指定大小容量的list, 如果入参小于0的话则抛出IllegalArgumentException不合法的参数异常。 ArrayList()1234567/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA;&#125; 构造一个带有初始容量为10的空list。 ArrayList(Collection&lt;? extends E&gt; c)123456789101112131415/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 构造一个list包含指定容器的元素，其中的元素顺序按照容器的遍历顺序。 trimToSize()1234567891011/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = Arrays.copyOf(elementData, size); &#125;&#125; 将当前ArrayList的实例的容量调整为当前含有的元素的个数。 这个方法可以节省存储空间。 ensureCapacity(int minCapacity)1234567891011121314151617181920 /** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; //如果数组为空，minExpand容量取0，否则取默认值10 int minExpand = (elementData != EMPTY_ELEMENTDATA) // any size if real element table ? 0 // larger than default for empty table. It's already supposed to be // at default size. : DEFAULT_CAPACITY;//如果minCapacity大于minExpand,则设为最小容量 if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; size()12345678/** * Returns the number of elements in this list. * * @return the number of elements in this list */public int size() &#123; return size;&#125; 返回当前list中所含元素的个数。 isEmpty()12345678/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements */public boolean isEmpty() &#123; return size == 0;&#125; 作用：判断当前list是否为空。 如果list中所含元素个数为0的话，表示为空，返回true，否则返回false。 contains(Object o)123456789101112/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains * at least one element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this list is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 作用：判断当前list是否包含指定元素。 如果包含则返回true，不包含则返回false。 indexOf(Object o)1234567891011121314151617181920/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int indexOf(Object o) &#123; //如果对象为空的话 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 返回元素在list中的第一个索引。 lastIndexOf(Object o)12345678910111213141516171819/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 返回数组list里面匹配的最后一个元素。 clone()123456789101112131415161718/** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */public Object clone() &#123; try &#123; @SuppressWarnings("unchecked") ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; //将修改次数计数器置位0 return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125;&#125; 浅拷贝：只复制当前对象，对该对象内部的引用不能复制。 深拷贝：对对象内部的引用均复制，是创建一个新的实例，并复制实例。 返回当前数组list实例的浅拷贝(元素本身不复制)。 toArray()1234567891011121314151617/** * Returns an array containing all of the elements in this list * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be "safe" in that no references to it are * maintained by this list. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this list in * proper sequence */public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; 以合适的顺序（从第一个到最后一个元素）返回当前list中的所有元素到一个数组 返回一个数组，这个数组包含当前list的所有元素，并且以从第一个到最后一个元素的顺序。 toArray(T[] a)get(int index)123456789101112/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; rangeCheck(index); //对index进行检查，是否超出了边界 return elementData(index);&#125; 返回指定位置上的元素。]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object源码解析(JDK1.8)]]></title>
    <url>%2F2018%2F10%2F21%2FObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8)%2F</url>
    <content type="text"><![CDATA[Object源码解析(JDK1.8)Object类是Java中所有类的基类，在编译时会自动导入，位于java.lang包中，而Object中具有的属性和行为，是Java语言设计背后的思维体现。这里写的代码是JDK8中的，其他版本的JDK可能略有不同。 包含的方法如下图： 所有方法按照字母a-z排序 Object类方法说明： Object类中的方法大部分都是native方法（如上图中方法前有一个绿色的实心小圆圈，圆圈的右上角有大写字母N，表示该方法是一个native方法），用此关键字修饰的方法是java中的本地方法，一般都是用C/C++语言实现的。 构造方法Object类中没有显示的提供构造方法，是编译器默认提供的。 registerNatives()方法1234private static native void registerNatives(); static &#123; registerNatives(); &#125; registerNatives()是一个本地方法，具体是用C/C++在DLL中实现的，在类加载的时候执行。 getClass()方法1234567891011121314151617181920/** * Returns the runtime class of this &#123;@code Object&#125;. The returned * &#123;@code Class&#125; object is the object that is locked by &#123;@code * static synchronized&#125; methods of the represented class. * * &lt;p&gt;&lt;b&gt;The actual result type is &#123;@code Class&lt;? extends |X|&gt;&#125; * where &#123;@code |X|&#125; is the erasure of the static type of the * expression on which &#123;@code getClass&#125; is called.&lt;/b&gt; For * example, no cast is required in this code fragment:&lt;/p&gt; * * &lt;p&gt; * &#123;@code Number n = 0; &#125;&lt;br&gt; * &#123;@code Class&lt;? extends Number&gt; c = n.getClass(); &#125; * &lt;/p&gt; * * @return The &#123;@code Class&#125; object that represents the runtime * class of this object. * @jls 15.8.2 Class Literals */public final native Class&lt;?&gt; getClass(); 返回当前对象运行时的类，final关键字修饰说明这个方法不能被子类重写。 hashcode()方法123456789101112131415161718192021222324252627282930313233343536/** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * &#123;@link java.util.HashMap&#125;. * &lt;p&gt; * The general contract of &#123;@code hashCode&#125; is: * &lt;ul&gt; * &lt;li&gt;Whenever it is invoked on the same object more than once during * an execution of a Java application, the &#123;@code hashCode&#125; method * must consistently return the same integer, provided no information * used in &#123;@code equals&#125; comparisons on the object is modified. * This integer need not remain consistent from one execution of an * application to another execution of the same application. * &lt;li&gt;If two objects are equal according to the &#123;@code equals(Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of * the two objects must produce the same integer result. * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal * according to the &#123;@link java.lang.Object#equals(java.lang.Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of the * two objects must produce distinct integer results. However, the * programmer should be aware that producing distinct integer results * for unequal objects may improve the performance of hash tables. * &lt;/ul&gt; * &lt;p&gt; * As much as is reasonably practical, the hashCode method defined by * class &#123;@code Object&#125; does return distinct integers for distinct * objects. (This is typically implemented by converting the internal * address of the object into an integer, but this implementation * technique is not required by the * Java&amp;trade; programming language.) * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */public native int hashCode(); Object类中的hashcode()方法用来鉴定两个对象是否相等，返回对象在内存中地址转换成的一个 int类型的值。如果没有重写hashcode()方法，任何对象的hashcode()方法都是不相等的。 equals()方法入参：Object 返回值：Boolean类型， 123456789101112131415161718192021222324/** * Indicates whether some other object is "equal to" this one. * &lt;p&gt; * The &#123;@code equals&#125; method for class &#123;@code Object&#125; implements * the most discriminating possible equivalence relation on objects; * that is, for any non-null reference values &#123;@code x&#125; and * &#123;@code y&#125;, this method returns &#123;@code true&#125; if and only * if &#123;@code x&#125; and &#123;@code y&#125; refer to the same object * (&#123;@code x == y&#125; has the value &#123;@code true&#125;). * &lt;p&gt; * Note that it is generally necessary to override the &#123;@code hashCode&#125; * method whenever this method is overridden, so as to maintain the * general contract for the &#123;@code hashCode&#125; method, which states * that equal objects must have equal hash codes. * * @param obj the reference object with which to compare. * @return &#123;@code true&#125; if this object is the same as the obj * argument; &#123;@code false&#125; otherwise. * @see #hashCode() * @see java.util.HashMap */public boolean equals(Object obj) &#123; return (this == obj);&#125; Object类中的equals()方法用来判断两个对象是否相等。如果当前对象与传入的对象相同，则返回true，否则返回false。 注意：这个equals()方法没有被final关键字修饰，也就是说可以被子类重写，比如说String类型里面重写了equals()方法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Compares this string to the specified object. The result is &#123;@code * true&#125; if and only if the argument is not &#123;@code null&#125; and is a &#123;@code * String&#125; object that represents the same sequence of characters as this * object. * * @param anObject * The object to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if the given object represents a &#123;@code String&#125; * equivalent to this string, &#123;@code false&#125; otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */public boolean equals(Object anObject) &#123; //如果对象相等的话，直接返回true if (this == anObject) &#123; return true; &#125; /** * 如果对象不相同，则比较String中的value值是否相同。 * 首先判断传入的对象是不是String类型的实例： * 如果是，将字符串转换成字符数组接着逐一比较数组里的字符是否相同，如果不同，直接返回false。 * 遍历结束，则表示相同，返回true。 * */ if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 如果传入的对象和当前对象是同一个对象，返回true；如果传入的对象是String类型的实例，则判断传入对象的String和当前String是否相等，如果相等，则返回true，否则返回false。 instanceof关键字的作用：判断左边的对象是否是右边类的实例，例如 objectA.instanceof(ClassB)判断对象A是否是类B的实例，如果是则返回true，否则返回false。 clone()方法1234567891011/** * Creates and returns a copy of this object. * @return a clone of this instance. * @throws CloneNotSupportedException if the object's class does not * support the &#123;@code Cloneable&#125; interface. Subclasses * that override the &#123;@code clone&#125; method can also * throw this exception to indicate that an instance cannot * be cloned. * @see java.lang.Cloneable */protected native Object clone() throws CloneNotSupportedException; 返回当前实例的克隆对象。 toString()方法123456789101112131415161718192021222324/** * Returns a string representation of the object. In general, the * &#123;@code toString&#125; method returns a string that * "textually represents" this object. The result should * be a concise but informative representation that is easy for a * person to read. * It is recommended that all subclasses override this method. * &lt;p&gt; * The &#123;@code toString&#125; method for class &#123;@code Object&#125; * returns a string consisting of the name of the class of which the * object is an instance, the at-sign character `&#123;@code @&#125;', and * the unsigned hexadecimal representation of the hash code of the * object. In other words, this method returns a string equal to the * value of: * &lt;blockquote&gt; * &lt;pre&gt; * getClass().getName() + '@' + Integer.toHexString(hashCode()) * &lt;/pre&gt;&lt;/blockquote&gt; * * @return a string representation of the object. */public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; 返回表示当前对象的字符串，字符串的形式是类名@hashCode的十六进制表示，比如objectA是classB的实例，ObjectA的hashCode为c,而c的十六进制为d,则调用ObjectA的toString()方法返回ClassB@d。推荐所有的子类都重写这个方法。 notify()方法123456789101112131415161718192021222324252627282930313233/** * Wakes up a single thread that is waiting on this object's * monitor. If any threads are waiting on this object, one of them * is chosen to be awakened. The choice is arbitrary and occurs at * the discretion of the implementation. A thread waits on an object's * monitor by calling one of the &#123;@code wait&#125; methods. * &lt;p&gt; * The awakened thread will not be able to proceed until the current * thread relinquishes the lock on this object. The awakened thread will * compete in the usual manner with any other threads that might be * actively competing to synchronize on this object; for example, the * awakened thread enjoys no reliable privilege or disadvantage in being * the next thread to lock this object. * &lt;p&gt; * This method should only be called by a thread that is the owner * of this object's monitor. A thread becomes the owner of the * object's monitor in one of three ways: * &lt;ul&gt; * &lt;li&gt;By executing a synchronized instance method of that object. * &lt;li&gt;By executing the body of a &#123;@code synchronized&#125; statement * that synchronizes on the object. * &lt;li&gt;For objects of type &#123;@code Class,&#125; by executing a * synchronized static method of that class. * &lt;/ul&gt; * &lt;p&gt; * Only one thread at a time can own an object's monitor. * * @throws IllegalMonitorStateException if the current thread is not * the owner of this object's monitor. * @see java.lang.Object#notifyAll() * @see java.lang.Object#wait() */public final native void notify(); 唤醒在该对象监视器(Monitor)里等待的一个线程。 notifyAll()方法1234567891011121314151617181920212223/** * Wakes up all threads that are waiting on this object's monitor. A * thread waits on an object's monitor by calling one of the * &#123;@code wait&#125; methods. * &lt;p&gt; * The awakened threads will not be able to proceed until the current * thread relinquishes the lock on this object. The awakened threads * will compete in the usual manner with any other threads that might * be actively competing to synchronize on this object; for example, * the awakened threads enjoy no reliable privilege or disadvantage in * being the next thread to lock this object. * &lt;p&gt; * This method should only be called by a thread that is the owner * of this object's monitor. See the &#123;@code notify&#125; method for a * description of the ways in which a thread can become the owner of * a monitor. * * @throws IllegalMonitorStateException if the current thread is not * the owner of this object's monitor. * @see java.lang.Object#notify() * @see java.lang.Object#wait() */public final native void notifyAll(); 唤醒当前对象监视器下的所有线程。 wait(long)方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Causes the current thread to wait until either another thread invokes the * &#123;@link java.lang.Object#notify()&#125; method or the * &#123;@link java.lang.Object#notifyAll()&#125; method for this object, or a * specified amount of time has elapsed. * &lt;p&gt; * The current thread must own this object's monitor. * &lt;p&gt; * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to * place itself in the wait set for this object and then to relinquish * any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt; * becomes disabled for thread scheduling purposes and lies dormant * until one of four things happens: * &lt;ul&gt; * &lt;li&gt;Some other thread invokes the &#123;@code notify&#125; method for this * object and thread &lt;var&gt;T&lt;/var&gt; happens to be arbitrarily chosen as * the thread to be awakened. * &lt;li&gt;Some other thread invokes the &#123;@code notifyAll&#125; method for this * object. * &lt;li&gt;Some other thread &#123;@linkplain Thread#interrupt() interrupts&#125; * thread &lt;var&gt;T&lt;/var&gt;. * &lt;li&gt;The specified amount of real time has elapsed, more or less. If * &#123;@code timeout&#125; is zero, however, then real time is not taken into * consideration and the thread simply waits until notified. * &lt;/ul&gt; * The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this * object and re-enabled for thread scheduling. It then competes in the * usual manner with other threads for the right to synchronize on the * object; once it has gained control of the object, all its * synchronization claims on the object are restored to the status quo * ante - that is, to the situation as of the time that the &#123;@code wait&#125; * method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the * invocation of the &#123;@code wait&#125; method. Thus, on return from the * &#123;@code wait&#125; method, the synchronization state of the object and of * thread &#123;@code T&#125; is exactly as it was when the &#123;@code wait&#125; method * was invoked. * &lt;p&gt; * A thread can also wake up without being notified, interrupted, or * timing out, a so-called &lt;i&gt;spurious wakeup&lt;/i&gt;. While this will rarely * occur in practice, applications must guard against it by testing for * the condition that should have caused the thread to be awakened, and * continuing to wait if the condition is not satisfied. In other words, * waits should always occur in loops, like this one: * &lt;pre&gt; * synchronized (obj) &#123; * while (&amp;lt;condition does not hold&amp;gt;) * obj.wait(timeout); * ... // Perform action appropriate to condition * &#125; * &lt;/pre&gt; * (For more information on this topic, see Section 3.2.3 in Doug Lea's * "Concurrent Programming in Java (Second Edition)" (Addison-Wesley, * 2000), or Item 50 in Joshua Bloch's "Effective Java Programming * Language Guide" (Addison-Wesley, 2001). * * &lt;p&gt;If the current thread is &#123;@linkplain java.lang.Thread#interrupt() * interrupted&#125; by any thread before or while it is waiting, then an * &#123;@code InterruptedException&#125; is thrown. This exception is not * thrown until the lock status of this object has been restored as * described above. * * &lt;p&gt; * Note that the &#123;@code wait&#125; method, as it places the current thread * into the wait set for this object, unlocks only this object; any * other objects on which the current thread may be synchronized remain * locked while the thread waits. * &lt;p&gt; * This method should only be called by a thread that is the owner * of this object's monitor. See the &#123;@code notify&#125; method for a * description of the ways in which a thread can become the owner of * a monitor. * * @param timeout the maximum time to wait in milliseconds. * @throws IllegalArgumentException if the value of timeout is * negative. * @throws IllegalMonitorStateException if the current thread is not * the owner of the object's monitor. * @throws InterruptedException if any thread interrupted the * current thread before or while the current thread * was waiting for a notification. The &lt;i&gt;interrupted * status&lt;/i&gt; of the current thread is cleared when * this exception is thrown. * @see java.lang.Object#notify() * @see java.lang.Object#notifyAll() */public final native void wait(long timeout) throws InterruptedException; 使当前线程等待直到另外一个线程调用等待线程的notify()方法或者notifyAll()方法，或者等待指定的时间。 wait(long,int)方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * Causes the current thread to wait until another thread invokes the * &#123;@link java.lang.Object#notify()&#125; method or the * &#123;@link java.lang.Object#notifyAll()&#125; method for this object, or * some other thread interrupts the current thread, or a certain * amount of real time has elapsed. * &lt;p&gt; * This method is similar to the &#123;@code wait&#125; method of one * argument, but it allows finer control over the amount of time to * wait for a notification before giving up. The amount of real time, * measured in nanoseconds, is given by: * &lt;blockquote&gt; * &lt;pre&gt; * 1000000*timeout+nanos&lt;/pre&gt;&lt;/blockquote&gt; * &lt;p&gt; * In all other respects, this method does the same thing as the * method &#123;@link #wait(long)&#125; of one argument. In particular, * &#123;@code wait(0, 0)&#125; means the same thing as &#123;@code wait(0)&#125;. * &lt;p&gt; * The current thread must own this object's monitor. The thread * releases ownership of this monitor and waits until either of the * following two conditions has occurred: * &lt;ul&gt; * &lt;li&gt;Another thread notifies threads waiting on this object's monitor * to wake up either through a call to the &#123;@code notify&#125; method * or the &#123;@code notifyAll&#125; method. * &lt;li&gt;The timeout period, specified by &#123;@code timeout&#125; * milliseconds plus &#123;@code nanos&#125; nanoseconds arguments, has * elapsed. * &lt;/ul&gt; * &lt;p&gt; * The thread then waits until it can re-obtain ownership of the * monitor and resumes execution. * &lt;p&gt; * As in the one argument version, interrupts and spurious wakeups are * possible, and this method should always be used in a loop: * &lt;pre&gt; * synchronized (obj) &#123; * while (&amp;lt;condition does not hold&amp;gt;) * obj.wait(timeout, nanos); * ... // Perform action appropriate to condition * &#125; * &lt;/pre&gt; * This method should only be called by a thread that is the owner * of this object's monitor. See the &#123;@code notify&#125; method for a * description of the ways in which a thread can become the owner of * a monitor. * * @param timeout the maximum time to wait in milliseconds. * @param nanos additional time, in nanoseconds range * 0-999999. * @throws IllegalArgumentException if the value of timeout is * negative or the value of nanos is * not in the range 0-999999. * @throws IllegalMonitorStateException if the current thread is not * the owner of this object's monitor. * @throws InterruptedException if any thread interrupted the * current thread before or while the current thread * was waiting for a notification. The &lt;i&gt;interrupted * status&lt;/i&gt; of the current thread is cleared when * this exception is thrown. */public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout);&#125; 和只有一个入参的wait(long)方法类似，但它允许更精细的时间控制，以纳秒进行实时的统计。 wait()方法1234567891011121314151617181920212223242526272829303132333435363738394041/** * Causes the current thread to wait until another thread invokes the * &#123;@link java.lang.Object#notify()&#125; method or the * &#123;@link java.lang.Object#notifyAll()&#125; method for this object. * In other words, this method behaves exactly as if it simply * performs the call &#123;@code wait(0)&#125;. * &lt;p&gt; * The current thread must own this object's monitor. The thread * releases ownership of this monitor and waits until another thread * notifies threads waiting on this object's monitor to wake up * either through a call to the &#123;@code notify&#125; method or the * &#123;@code notifyAll&#125; method. The thread then waits until it can * re-obtain ownership of the monitor and resumes execution. * &lt;p&gt; * As in the one argument version, interrupts and spurious wakeups are * possible, and this method should always be used in a loop: * &lt;pre&gt; * synchronized (obj) &#123; * while (&amp;lt;condition does not hold&amp;gt;) * obj.wait(); * ... // Perform action appropriate to condition * &#125; * &lt;/pre&gt; * This method should only be called by a thread that is the owner * of this object's monitor. See the &#123;@code notify&#125; method for a * description of the ways in which a thread can become the owner of * a monitor. * * @throws IllegalMonitorStateException if the current thread is not * the owner of the object's monitor. * @throws InterruptedException if any thread interrupted the * current thread before or while the current thread * was waiting for a notification. The &lt;i&gt;interrupted * status&lt;/i&gt; of the current thread is cleared when * this exception is thrown. * @see java.lang.Object#notify() * @see java.lang.Object#notifyAll() */public final void wait() throws InterruptedException &#123; wait(0);&#125; finalize()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Called by the garbage collector on an object when garbage collection * determines that there are no more references to the object. * A subclass overrides the &#123;@code finalize&#125; method to dispose of * system resources or to perform other cleanup. * &lt;p&gt; * The general contract of &#123;@code finalize&#125; is that it is invoked * if and when the Java&amp;trade; virtual * machine has determined that there is no longer any * means by which this object can be accessed by any thread that has * not yet died, except as a result of an action taken by the * finalization of some other object or class which is ready to be * finalized. The &#123;@code finalize&#125; method may take any action, including * making this object available again to other threads; the usual purpose * of &#123;@code finalize&#125;, however, is to perform cleanup actions before * the object is irrevocably discarded. For example, the finalize method * for an object that represents an input/output connection might perform * explicit I/O transactions to break the connection before the object is * permanently discarded. * &lt;p&gt; * The &#123;@code finalize&#125; method of class &#123;@code Object&#125; performs no * special action; it simply returns normally. Subclasses of * &#123;@code Object&#125; may override this definition. * &lt;p&gt; * The Java programming language does not guarantee which thread will * invoke the &#123;@code finalize&#125; method for any given object. It is * guaranteed, however, that the thread that invokes finalize will not * be holding any user-visible synchronization locks when finalize is * invoked. If an uncaught exception is thrown by the finalize method, * the exception is ignored and finalization of that object terminates. * &lt;p&gt; * After the &#123;@code finalize&#125; method has been invoked for an object, no * further action is taken until the Java virtual machine has again * determined that there is no longer any means by which this object can * be accessed by any thread that has not yet died, including possible * actions by other objects or classes which are ready to be finalized, * at which point the object may be discarded. * &lt;p&gt; * The &#123;@code finalize&#125; method is never invoked more than once by a Java * virtual machine for any given object. * &lt;p&gt; * Any exception thrown by the &#123;@code finalize&#125; method causes * the finalization of this object to be halted, but is otherwise * ignored. * * @throws Throwable the &#123;@code Exception&#125; raised by this method * @see java.lang.ref.WeakReference * @see java.lang.ref.PhantomReference * @jls 12.6 Finalization of Class Instances */protected void finalize() throws Throwable &#123; &#125; JAVA内存回收机制是通过根节点到当前对象之间有没有一条引用链指向来判断对象是否可以回收的。 该对象没有引用指向的时候，垃圾收集器在合适的时机调用该对象的finalize()方法对该对象进行回收。 参考资料 https://blog.csdn.net/benjaminlee1/article/details/72843713]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>缤纷生活</category>
      </categories>
      <tags>
        <tag>缤纷生活</tag>
      </tags>
  </entry>
</search>
