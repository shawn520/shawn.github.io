<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ArrayList 源码解析(JDK1.7)]]></title>
    <url>%2F2019%2F07%2F09%2FArrayList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK7)%2F</url>
    <content type="text"><![CDATA[ArrayList 源码解析(JDK1.7)包含的方法如下图： 所有方法按照字母a-z排序 属性DEFAULT_CAPACITY1234/** * 默认的初始容量 */private static final int DEFAULT_CAPACITY = 10; list的默认初始容量。 EMPTY_ELEMENTDATA1234/** * Shared empty array instance used for empty instances.空的对象数组 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 空的数组对象。 elementData1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == EMPTY_ELEMENTDATA will be expanded to * DEFAULT_CAPACITY when the first element is added. */private transient Object[] elementData; 当插入第一个元素的时候，空的list的容量将会从0扩展到10. size123456/** * The size of the ArrayList (the number of elements it contains). * 数组的大小 * @serial */ private int size; 数组中含有的元素的个数。 构造函数ArrayList(int initialCapacity)1234567891011121314/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity];&#125; 构造一个带有指定大小容量的list, 如果入参小于0的话则抛出IllegalArgumentException不合法的参数异常。 ArrayList()1234567/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA;&#125; 构造一个带有初始容量为10的空list。 ArrayList(Collection&lt;? extends E&gt; c)123456789101112131415/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 构造一个list包含指定容器的元素，其中的元素顺序按照容器的遍历顺序。 trimToSize()1234567891011/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = Arrays.copyOf(elementData, size); &#125;&#125; 将当前ArrayList的实例的容量调整为当前含有的元素的个数。 这个方法可以节省存储空间。 ensureCapacity(int minCapacity)1234567891011121314151617181920 /** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; //如果数组为空，minExpand容量取0，否则取默认值10 int minExpand = (elementData != EMPTY_ELEMENTDATA) // any size if real element table ? 0 // larger than default for empty table. It's already supposed to be // at default size. : DEFAULT_CAPACITY;//如果minCapacity大于minExpand,则设为最小容量 if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; size()12345678/** * Returns the number of elements in this list. * * @return the number of elements in this list */public int size() &#123; return size;&#125; 返回当前list中所含元素的个数。 isEmpty()12345678/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements */public boolean isEmpty() &#123; return size == 0;&#125; 作用：判断当前list是否为空。 如果list中所含元素个数为0的话，表示为空，返回true，否则返回false。 contains(Object o)123456789101112/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains * at least one element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this list is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 作用：判断当前list是否包含指定元素。 如果包含则返回true，不包含则返回false。 indexOf(Object o)1234567891011121314151617181920/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int indexOf(Object o) &#123; //如果对象为空的话 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 返回元素在list中的第一个索引。 lastIndexOf(Object o)12345678910111213141516171819/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 返回数组list里面匹配的最后一个元素。 clone()123456789101112131415161718/** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */public Object clone() &#123; try &#123; @SuppressWarnings("unchecked") ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; //将修改次数计数器置位0 return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125;&#125; 浅拷贝：只复制当前对象，对该对象内部的引用不能复制。 深拷贝：对对象内部的引用均复制，是创建一个新的实例，并复制实例。 返回当前数组list实例的浅拷贝(元素本身不复制)。 toArray()1234567891011121314151617/** * Returns an array containing all of the elements in this list * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be "safe" in that no references to it are * maintained by this list. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this list in * proper sequence */public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; 以合适的顺序（从第一个到最后一个元素）返回当前list中的所有元素到一个数组 返回一个数组，这个数组包含当前list的所有元素，并且以从第一个到最后一个元素的顺序。 toArray(T[] a)get(int index)123456789101112/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; rangeCheck(index); //对index进行检查，是否超出了边界 return elementData(index);&#125; 返回指定位置上的元素。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码解析(JDK7)]]></title>
    <url>%2F2019%2F07%2F09%2FConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88JDK7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap源码解析(JDK7) Constants (常量)12345/** * The default initial capacity for this table, * used when not otherwise specified in a constructor. */static final int DEFAULT_INITIAL_CAPACITY = 16; 默认的最初的容量为16 12345/** * The default load factor for this table, used when not * otherwise specified in a constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f; 默认的负载因子为0.75 12345/** * The default concurrency level for this table, used when not * otherwise specified in a constructor. */static final int DEFAULT_CONCURRENCY_LEVEL = 16; 默认的并发级别为16 1234567/** * The maximum capacity, used if a higher value is implicitly * specified by either of the constructors with arguments. MUST * be a power of two &lt;= 1&lt;&lt;30 to ensure that entries are indexable * using ints. */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 最大容量为2的32次幂。 123456/** * The minimum capacity for per-segment tables. Must be a power * of two, at least two to avoid immediate resizing on next use * after lazy construction. */static final int MIN_SEGMENT_TABLE_CAPACITY = 2; 最小的段数。 12345/** * The maximum number of segments to allow; used to bound * constructor arguments. Must be power of two less than 1 &lt;&lt; 24. */static final int MAX_SEGMENTS = 1 &lt;&lt; 16; // slightly conservative 略微保守的最大段数为2的16次幂。 1234567/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */static final int RETRIES_BEFORE_LOCK = 2; 字段(Fields)12345678910111213/** * A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. */private transient final int hashSeed = randomHashSeed(this);private static int randomHashSeed(ConcurrentHashMap instance) &#123; if (sun.misc.VM.isBooted() &amp;&amp; Holder.ALTERNATIVE_HASHING) &#123; return sun.misc.Hashing.randomHashSeed(instance); &#125; return 0;&#125; transient: 用transient关键字标记的成员变量不参与序列化过程。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Thread 源码阅读]]></title>
    <url>%2F2019%2F07%2F09%2FThread%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Thread 源码阅读 123publicclass Thread implements Runnable &#123;&#125; 所有Thread类实现了Runnable接口并实现了run()方法，为什么叫Runnable，而不是Running呢? 那是因为线程是可运行状态，并不表示此时此刻正在运行，线程的运行还需要处理器的调度。 构造方法1234public Thread(ThreadGroup group, Runnable target, String name,long stackSize) &#123;init(group, target, name, stackSize);&#125; 方法currentThread()返回当前执行线程对象的一个引用。 123456/*** Returns a reference to the currently executing thread object.** @return the currently executing thread.*/public static native Thread currentThread(); sleep(long millis)使当前执行的线程睡眠指定的 毫秒。当传入的时间millis为负数时，抛出IllegalArgumentException异常。 1public static native void sleep(long millis) throws InterruptedException; start()使当前线程开始执行。注意：一个已经执行的线程是不能执行start()方法的。 12345678910111213141516171819202122232425262728293031public synchronized void start() &#123; /** * This method is not invoked for the main method thread or "system" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state "NEW". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125; void interrupt()interrupt()中断当前线程的执行。 1234567891011121314public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0();&#125; boolean isInterrupted()检查当前线程是不是被中断。 123public boolean isInterrupted() &#123; return isInterrupted(false); &#125; 线程的优先级123456public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 线程的优先级分为10级，最小优先级为1，最大优先级为10,普通优先级为5. setDaemon(boolean on)如果on = true，则设置当前线程为守护线程。 注意：这个方法必须在线程启动前调用。 1234567public final void setDaemon(boolean on) &#123; checkAccess(); if (isAlive()) &#123; throw new IllegalThreadStateException(); &#125; daemon = on;&#125;]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Testing</tag>
      </tags>
  </entry>
</search>
