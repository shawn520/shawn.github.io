<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TreeMap源码阅读]]></title>
    <url>%2F2019%2F07%2F18%2FSource%20reading%2FTreeMap%2F</url>
    <content type="text"><![CDATA[想学习ConcurrentHashMap源码，先阅读理解TreeMap源码，顺便复习一下红黑树, 提升一下功力。 为后续阅读ConcurrentHashMap源码打基础。 前言基于红黑树的TreeMap增删该查操作最坏时间复杂度为O(lgn)。实现了NavigableMap接口，保证key有序。 红黑树特性 根节点必须红色 节点必须是红色或者黑色 不能有两个连续的红色节点 Nil节点为黑色 根节点到Nil节点的所有路径，黑色节点个数相同。 源码红黑树数据结构定义1234567891011121314151617static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; // 指向父节点 boolean color = BLACK; // 默认黑色 /** * 初始化节点 */ Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125;&#125; 类名和属性TreeMap继承AbstractMap, 实现NavigableMap接口，NavigableMap接口继承SortedMap, key有序。类图如下所示。红色表示接口，蓝色表示抽象类，绿色表示线程安全。 1234567891011121314151617181920public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123; /** * comparator用来维持treeMap有序 */ private final Comparator&lt;? super K&gt; comparator; private transient Entry&lt;K,V&gt; root; /** * 树中所含节点的个数 */ private transient int size = 0; /** * 记录树结构修改的次数 */ private transient int modCount = 0;&#125; 插入操作插入操作分为两步： 根据规则寻找插入位置。put() 插入之后，如果不满足红黑树的约束条件fixAfterInsertion(e)，则重新着色后者通过左旋右旋等操作是满足红黑树的约束条件。 根据规则寻找插入位置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 向map中插入指定的键值对，如果key存在，则替换和返回旧的value。 * * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException 如果key为null抛出空指针异常 */public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; // t 指向当前节点，开始指向根节点。 // 如果根节点不存在，则插入节点为根节点。 if (t == null) &#123; compare(key, key); // type (and possibly null) check // 因为是根节点，所以parent为null root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // 寻找插入位置 Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; do &#123; // parent指向当前节点 parent = t; cmp = cpr.compare(key, t.key); // 小于当前节点则left if (cmp &lt; 0) t = t.left; // 大于当前节点则right else if (cmp &gt; 0) t = t.right; else return t.setValue(value); //等于则覆盖，并返回原value // 直到找到合适位置 &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 初始化entry Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); // 插入 if (cmp &lt; 0) parent.left = e; else parent.right = e; // 第二步，调整使满足红黑树特性。 fixAfterInsertion(e); size++; modCount++; return null;&#125; 调整使满足红黑树特性插入节点的父节点为红色时，不满足红黑树特性第三条，需要进行调整。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; // 新插入的节点默认为红色 x.color = RED; // 插入节点的父节点为红色时，不满足红黑树特性第三条，需要调整 while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; // 父节点是祖父节点的左孩子 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; // y指向大（右）叔节点 Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); // 右叔节点为红色的话，进行局部颜色调整，递归向上，最坏时间复杂度O(lgn) if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); // 如果右叔为黑色的话 &#125; else &#123; // 且如果x是父节点的右孩子，左旋调整为左孩子 if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); // 左旋 &#125; // 父节点设置为黑色，祖父节点设置为红色，并对祖父节点右旋操作 setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; // 父节点是祖父节点的右孩子 &#125; else &#123; // y指向小（左）叔 Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); // 如果左叔为红色，设置父节点和左叔为黑色，祖父节点为红色，x指向祖父节点，一路向上。 if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); // 如果左叔为黑色 &#125; else &#123; // 如果x为左孩子，则右旋转为右孩子情况 if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; // 父节点设置成黑色，祖父设置成红色，且祖父节点左旋 setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; // 根节点永远使黑色 root.color = BLACK;&#125; 左旋左旋、右旋的目的是通过不断旋转是树达到平衡，提升二叉树的使用效率。 左旋：以某个节点为中心，将它下沉到当前节点的左孩子节点位置，让当前右孩子节点作为局部根节点。 右旋和左旋类似。此处以左旋为例。 1234567891011121314151617181920212223private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; // r指向当前节点的右孩子 Entry&lt;K,V&gt; r = p.right; // r的左子树设置为p的右子树 p.right = r.left; if (r.left != null) r.left.parent = p; // r的父指针指向p的父指针 r.parent = p.parent; // 如果p为根节点，则新的根节点为r if (p.parent == null) root = r; // 否则将p的父节点指向p的指针指向r else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; // r的左指针指向p, 同时p的父指针指向r r.left = p; p.parent = r; &#125;&#125; 举个栗子参考资料码出高效 java开发手册]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务之赤壁大战]]></title>
    <url>%2F2019%2F07%2F13%2Fjava%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E8%B5%A4%E5%A3%81%E5%A4%A7%E6%88%98%2F</url>
    <content type="text"><![CDATA[话说曹操官渡之战大获全胜，收编了袁绍的大批将士和军队，有搞python的，有搞js的，有搞ruby的，有搞c++的，还有搞php的，不一而足。 本文转自公众号互联网侦察，文章把微服务向ServiceMesh的进化融入到了三国故事中，妙趣横生。故事比较长，大家慢慢看，精彩的在后边。 浩浩荡荡，号称百万大军，正向东边来袭。 刘备率领自己的Java大军，哦不，其实也就万人不到，一边抵御一边向东逃去。 刘备：“曹操大军压进，如何是好啊？” 诸葛亮：“主公不必多虑，我等可投奔东吴。” 刘备：“他们岂肯逆曹而收留我们？” 诸葛亮：“亮自有妙计，且听我慢慢道来。” 诸葛亮：“东吴世代熟悉水战，创始人孙坚，一直使用go语言，其儿孙策继承父志，搞出了Docker。现在孙策之弟孙权在位，我们可以说服他联合抗曹。” 刘备：“talk is cheap，你先带赵云去东吴游说，我们带着军队随后就到。” 东吴诸葛亮来到东吴，说明了来意。 诸葛亮：“曹操正率百万大军向东吴进攻，目前形势危急，我主刘备欲助东吴一起抗曹”。 张昭：“主公，万万不可听信此人，曹操明明是要进攻刘备，与我东吴何干？” 诸葛亮：“此言差矣，如果我主刘备被灭，东吴离灭亡还会远吗？” 张昭：“你说你来帮我们一起抗曹，但是你们自己兵力微弱，被曹操打得节节败退，又如何帮我们？” 诸葛亮：“我主自幼苦练Java，又有关羽张飞赵云等良将，最近我又在研究微服务兵法，配合东吴Docker可以发挥最大的效能。” 张昭：“什么乱七八糟的，无非是想借我们的兵力而已。” 见两人在朝堂上吵吵闹闹，孙权一时头疼：“汝等暂且退下，容我三思。” 孙权回到房间，马上下诏书让周瑜回来。 周瑜周瑜回来见过孙权：“主公，事情我都听说了，我也是主张抗曹。” 孙权：“哦？你有把握吗？” 周瑜：“我一直在训练Docker水军，战斗力已经max，只是我要见那诸葛亮一见”。 说完，周瑜向诸葛亮的住处奔去。 诸葛亮早已正装等候。 周瑜：“诸葛先生，你的好意我心领了，但是你也知道，你军不到一万，加上我军也不到五万，如何抵抗曹操百万大军？” 诸葛亮：“曹操百万大军看似很多，其实都是纸老虎。你想，曹军大部分都是收编其他势力，比较杂乱，什么Python、JS、PHP、Ruby、C++，这些人在一起，相互之间无法配合，战斗力要大打折扣的。” 周瑜见诸葛亮一言就说到了要害，知道此人并不简单，决定继续试探。 周瑜：“汝可有良策？” 诸葛亮也不虚：“不如你我各自在手心写下计策，同时打开？” 周瑜一听，觉得有点意思，便拿笔在手心写下一字，诸葛亮也在手心写下一字。写完，两人头碰头，同时打开手心。 只见两人写下的是同一个字，“船”！ 周瑜：“我以为你会写火。” 诸葛亮哈哈大笑：“我也以为你会写火”。 看到了吗，英雄的想法总是相似的，无论他们多么想与对方不一样。 两人彻夜长谈，共同商定抗曹方案，从微服务谈到服务降级，限流，最后到Docker部署，制定了周详的作战计划。计划制定完毕，两人作了最后一次模拟演练，演练过程中，这二人竟然有一种惺惺相惜的感觉。 天亮了，周瑜离开了诸葛亮的住处，路上，他心思极重：“诸葛亮真乃旷世奇才，可惜和我各事其主，此人必不可久留。” 话分两头说，曹操这边倒是正在发愁。 曹营曹操：“我虽有百万大军，但是大部分是北方人士，到这东吴水土不服，特别是在水上作战，不像在陆地这般平稳，大批将士一到水上就脑袋发晕，这可如何是好呀？” 谋士荀彧率先开口：“主公所言极是，依我看来，咱们的部队兵力过于分散，搞Python的、搞PHP的、搞Ruby的、搞JS的、搞C++的，就像一片大海中的五个孤岛一样，无法联合作战啊。” 曹操：“爱卿所言正是我之担忧，我扩张太快，内部尚未磨合好，战斗力怕是要打些折扣啊。汝等有何良策？” 谋士程昱说道：“主公可听说过万能的重写？” 曹操：“这是何意？” 程昱：“我们可以选择一种语言，比如PHP，将其他语言实现的系统全部用这种语言重写一遍。这样大家都用一种语言，相互之间能够紧密配合。” 曹操：“这需要多长时间才能完成？” 程昱：“大概需要两年时间。” 曹操：“这可不行啊，兵贵神速，等上两年时间，那刘备和孙权都不知道能发展成什么样了。” 正在这时，曹营中一个声音说道：“我有一计，可以不用重写系统。” 庞统曹操寻声望去，只见坐下一人，样貌极丑，却一副胸有成竹的样子。 曹操：“哦？你说说看！” 庞统上前说到：“主公可听说过RPC？” 曹操：“RPC？什么东西？” 庞统：“就是远程过程调用的意思，虽然每个系统实现的语言不一样，但是只要遵循某种协议对外提供接口，比如都对外提供HTTP的接口，它们便可以相互调用。” 曹操：“这样就不用重写系统？来，你来给我详细说说。” 庞统：“比如那用Ruby写的系统，将自身能够提供的服务用HTTP接口封装一层，用PHP写的系统只需要发起一个HTTP的请求，便可以调用那Ruby系统提供的服务了。” 曹操：“嗯，明白了，这样改造需要多长时间？” 庞统：“因为不用重写，业务代码也不用大改，只需要用HTTP将某些服务包装，不出一周便能完成。” 曹操一听大喜：“行，就按照你的方案来，你来实施吧。” 庞统带领曹操的将士们对系统进行了改造，让原本割裂的五个不同语言的系统相互依赖，全部连了起来，完美地实现了曹操所需要的所有功能。 改罢，庞统暗自欣喜：“连环计已经完成，我现在该赶紧逃离曹营了。” 庞统想要坐筏渡江，只听后面有人拍了他的肩膀：“汝献此计策，不怕项上人头不保吗？” 徐庶庞统一听计策被识破，大惊失色，回头一看，原来是徐庶，提到嗓子眼的心又放了下来：“哎呀，元直兄，你这样吓人可不好啊，我心脏病都快被你吓出来了。” 这徐庶正是向刘备间接推荐诸葛亮之人，只是母亲被曹操控制，不得已而在曹营，发誓终生不为曹操献一计。 徐庶：“基于远程调用的分布式系统，我很早就在研究，这里面的复杂度可是单机程序所不能比拟的。” 庞统：“哦？愿闻其详。” 徐庶：“首先你要考虑被调用方挂了怎么办，要做限流和降级方案，还要考虑调用的负载均衡问题，还有服务的自动注册和发现，要有注册中心。你现在只是带领将士们实现了功能，根本没有考虑系统的稳定性和容灾情况，这不是把曹操往火坑里推？” 庞统一听哈哈大笑：“不愧是元直兄，不过老板们只要实现功能就行，谁会管什么容灾和稳定性？” 徐庶：“看来曹操天数将尽，你走吧，就当没见过我。” 庞统坐上竹筏往东吴而去。 开战月黑风高，长江上的浪花拍打着两岸，发出巨大的声响。江岸两边，曹操与周瑜隔江相对。就在今晚，曹操向孙刘发起了总攻，而周瑜也早已做好了战斗准备。 不远处，诸葛亮登上了七星台，与周瑜遥相呼应，相互配合。 曹操一声令下：“全军出击”。 百万大军驾驶着一艘战舰，朝周瑜这边驶来。 而那周瑜，只有区区十几艘小船，与那战舰一比，就像蚂蚁和大象。 曹操巨大的战舰向周瑜发动着猛烈的攻击。而那周瑜却不慌不忙，一面命令将士们顶住火力，另一面，暗中观察曹操那巨型战舰的火力分布。 他在寻找系统弱点。 突然，他发现曹操战舰的东北45度角火力有点慢，不像其他地方那么猛烈，一个火力开回比其他地方慢了50ms。 是的，就是这转瞬即逝的50ms，也瞒不过天才都督周瑜，他一声令下：“集火。” 由于周瑜的系统是基于微服务设计的，每个微服务都可以独立缩扩容。而系统又是用Docker部署。 周瑜军队需要做的就是将其他系统的docker容器关闭，然后启动进攻东北45度的docker容器。 两条命令，整个过程不超过半分钟。 逆转半分钟后，周瑜军队完成了集火的操作，曹操战舰的东北45度火力模块突然遭受了巨大流量火力冲击，瞬间挂掉了。 这一挂不要紧，关键是系统其他模块都依赖于这个东北45度火力模块，结果很多模块都无法正常工作了，整艘战舰，只有很少的几个点还能输出，其他火力全都哑了。 那东北45度区是用python写的，负责他的人正是曹军大将张辽。 张辽一看模块挂了，赶紧下令：“重启！重启这个模块！” 但是重启了之后，这个模块依然扛不住周瑜全军的火力，起来又挂了。 张辽：“不行了，必须要扩容，西北45度区夏侯敦那边没有火力，赶紧去那边调十台机器来扩容。” 那西北45度区是用nodejs写的，首领夏侯敦收到张辽的救援请求，马上调拨了十台机器给张辽。 但是要在这新的十台机器上部署python模块谈何容易，张辽部队全部上了，都在手动部署，装python环境，设置环境变量，拷贝代码，设置配置文件，这一套流程下来，十几分钟过去了。 结果要启动的时候，报错，python依赖的一个系统库与之前nodejs用的一个系统库冲突。 这下张辽是真的慌了：“重装，赶紧重装系统！” 嗯，整艘战舰的人都等着张辽在这重装系统，然后再装python环境，设置环境变量，拷贝代码，设置配置文件。 曹操曹操觉得此次胜利在握，正在战舰的监控室里一边喝酒，一边绣着十字绣。只见快一个小时了，十字绣已经绣了一半，还没有传来胜利的消息，便问身边人：“怎么还没有灭了周瑜？” 那身边人也是个欺上瞒下的主：“主公不必惊慌，咱们系统有一个小模块出了点问题，应该没有大碍。” 曹操：“我系统大大小小几十个模块，一个模块出问题算什么？” 他哪里知道，自己的系统早已被庞统全部连了起来，由于级联的效应，一个模块挂掉，已经足矣让整个系统80%功能不可用。 破曹张辽这边还在重装系统，周瑜的火力已经透过那东北45度火力模块打到了系统缓存层，缓存层很快出现了热点，一下子战舰着起了火，缓存层很快被击穿了，火力到达了数据库，数据库瞬间挂掉了。 张辽见情势不妙，赶紧连滚带爬去监控室里找曹操，只见曹操还在那优哉游哉喝着小酒，绣着十字绣。 张辽大喊：“主公，求求你别绣了。周瑜的火力已经打过来了，赶紧从后门逃走吧。” 曹操一开始还不相信，但见那火势很快烧到了监控室，自己只能带着将士们连滚带爬逃出战舰，朝那华容小道逃去。 周瑜登上曹操的战舰，没有寻得曹操，将士们都准备追击，周瑜却不慌不忙：“别忙着追那曹操，你们赶紧去那七星台，把诸葛亮先给我软禁起来。” 将士们来到七星台，只见台上早已空无一人，诸葛亮已经离开了东吴。 复盘曹操自从赤壁之战大败之后，一蹶不振，本来的绝对优势变成了天下三分的局势。 曹操有个习惯，每次吃了败战，都要面壁思过一段时间。吃了这么大一个败战，曹操已经面壁思过了一年时间。 一年后的今天，曹操准备好ppt，想着召集众将士们一起复盘。 曹操：“一年，一年了，我没有发动过战争，就是因为赤壁之战对我的打击太大。” 众将士不语。 曹操：“若郭奉孝在，不使我至此啊！” 郭奉孝名郭嘉，是曹操军中第零大谋士，可惜天天996，身体不好，赤壁之战前就病逝了。 众谋士听闻，都羞愧难当。 曹操：“你们谁能说说，赤壁之战失败的根因是什么？” 谋士荀彧先发言：“依我看都怪那庞统，献个什么连环计，把我们系统改得乱七八糟，没有考虑稳定性和容灾情况，才导致一个模块挂了，整个系统都挂了。” 曹操：“庞统何在？” 程昱：“庞统早已离职。” 曹操恨那庞统也是恨得牙痒痒，这种low逼谋士，技术渣，上来胡乱在系统里写些垃圾代码，把系统搞臭了就离职。 但是回头想想，也是自己先同意了让庞统去做改造，自己也有不可推卸的责任。 曹操：“还有其他原因吗？” 武将张辽也发言：“我们系统要缩扩容非常麻烦，要手动重装系统，再装环境。” 曹操：“其他人不也一样吗？” 荀彧：“非也，我听说那周瑜，用的是什么Docker，系统缩扩容半分钟就完成了，所以才导致我东北45度火力模块瞬间被集火挂掉。” 曹操一听，原来还有这段战况，开始后悔自己不应该盲目自信，坐在监控室里喝酒，他把那绣到一半的十字绣扔进了垃圾桶：“以后我再也不绣了。” 曹操：“我这一年来一直在反思，庞统那厮提出把系统改成分布式，用RPC互相调用，这并没有什么错，只是没考虑系统稳定性和容灾能力，例如网络不通，负载均衡，限流降级，服务发现等等才致此大败。我也有个疑问，为什么孙刘那边把容灾做得这么好呢！” 这时座下一人大喜：“时机已到！” 他站起身来：“这主要是因为刘备那里用的是Java，有很多’限流降级’，’服务发现’的系统可以直接使用。比如著名的Hystrix。” 司马懿站起来这位不是别人，正是曹营第一大谋士，与那郭嘉齐名的司马懿。 曹操：“那我们也可以拿过来用啊！” 司马懿：“主公，现在是不可能的，因为这些工具和Library很多都是用Java语言写的，和微服务密切绑定。” 司马懿一边说一边展示了一张图。 曹操立刻明白了：“这些微服务所依赖的库实际上和服务本身有了深度绑定，而我们有五种语言，每个语言都去实现一遍同样的工具和库，不但需要两三年时间，还是巨大的重复和浪费啊！” 司马懿道：“这些能力确实是每个服务都需要，但是并不需要每种语言都去实现这些能力。” 曹操和众臣表示不解。 司马懿开始放大招：“我们需要一个思维的升级，大家想想，这些微服务系统需要的特性其实是公共的，为什么不能把这些公共的特性做到底层平台中呢？想想看，我们做一个HTTP调用并不需要理解TCP的细节，那里边可是有流量控制，失败重传啊。” 荀彧恍然大悟：“软件业的所有问题果然是可以通过增加一个中间层来解决啊！” 曹操瞪了荀彧他一眼，这种总结的台词通常都是我来说的。 不过曹操老谋深算：“你能修改网络协议栈，来增加一个层来实现这些限流降级和服务发现的功能吗？” 司马懿道：“主公明鉴，确实不能，所以我们得改用代理的模式，服务本身不直接连接到其他的服务，而是将所有的流量到送到一个小的代理，由代理来实现需要的特性。 这个代理是通用的，所有我们可以用各种语言写微服务了。” （注：这个代理被称为sidecar，即边车，摩托车旁边的那个座位） ServiceMesh 司马懿：“我们的微服务都可以使用这种模式，这样就组成了一个网格，就是ServiceMesh。” 司马懿：请看看上图，浅蓝色部分代表咱们现在各个语言的业务模块，灰色部分代表代理(sidecar)，你可以看到，业务模块只和自己的代理通信，而真正实现相互之间通信的是代理。 程昱：“哦，我明白了，这倒是一种方法。那么实现ServiceMesh需要多长时间呢？” 司马懿：“不用自己造轮子了，现在已经有一些现成的方案，比如istio。” 曹操一听大喜：“行，就按照你说的来改造，但是这次改造完成，我们要执行严格的灾难测试。” 司马懿将代码回滚到庞统来之前，然后改造系统，把系统搭在了k8s之上，用上了istio，整个系统改造花了不到半年时间。 测试系统改造完毕，曹操安排了张辽对系统进行灾难测试，主要就是把一些模块搞挂。而那ServiceMesh+k8s搭载的系统，已经完全能够承受这种级别的灾难了。 曹操看到测试结果以后大喜，在铜雀台摆上了酒席宴请众将士。 曹操：“来，把甄姬叫来给大家跳个舞。” 众将士都沉浸在甄姬美妙的舞蹈当中，而曹操心里却已经盘算着如何灭掉孙刘。 参考文章https://philcalcado.com/2017/08/03/pattern_service_mesh.html]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费曼学习法]]></title>
    <url>%2F2019%2F07%2F12%2Fstudy%2F%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习一个新的知识的时候，有没有一种茶壶里煮饺子，有货到不出的感觉？明明这个知识点我已经明白了，“掌握”的很好了，但是别人问我的时候，还是闪烁其词，讲不明白？遇到相同问题或者类似问题时，还是不会运用。 我们需要一个高效的学习方法–费曼学习法 什么是费曼学习法？费曼学习法就是以通俗的语言来向别人传授你刚学到的知识点。平时我们的学习大部分都是被动的学习，或者说，学习的知识都没有很好的的到应用。比如说新学了一个知识点，能正确理解知识点的内容，以为自己已经掌握了，其实不然。学习有输入和输出两个过程，理解了知识点并不代表已经掌握了，就像茶壶里煮饺子，有货倒不出一样。如果能做到将高深的理论知识以通俗易懂的方式，解释给一个外行人听的话，才能说明真正掌握了这个知识。本质上来说：是以大妈级的语言来解释一些专业上的问题，用我们日常随处可见的现象来解释专业上的问题。总之：他是用极其具象的东西来回答高度抽象的东西。 费曼学习法的步骤费曼学习法分为四个步骤。 首先，假设你要把将要学习的知识传授给一个智力大概在8岁左右的小孩子，应该如何做，传授过程中是否有卡壳？如果有卡壳的地方，恰恰说明这里没有掌握，然后带着疑问重新学习资料，回顾。直到没有障碍为止，然后再简化语言，并将语言条理化。 123456graph LRA[假设需要传授给一个小孩子] --&gt; B&#123;是否卡壳?&#125;B -.-&gt;|是| C[回顾]C --&gt;A[假设需要传授给一个小孩子]B --&gt;|否| D[语言条理化, 简单化] 一、把它教给一个小孩子拿出一张白纸，在上方写下你想要学习的主题。想一下，如果你要把它教给一个孩子，你会讲哪些，并写下来。这里你的教授对象不是你自己那些聪明的成年朋友，而是一个 8 岁的孩子，他的词汇量和注意力刚好能够理解基本概念和关系。 许多人会倾向于使用复杂的词汇和行话来掩盖他们不明白的东西。问题是我们只在糊弄自己，因为我们不知道自己也不明白。另外，使用行话会隐藏周围人对我们的误解。 当你自始至终都用孩子可以理解的简单的语言写出一个想法（提示：只用最常见的单词），那么你便迫使自己在更深层次上理解了该概念，并简化了观点之间的关系和联系。如果你努力，就会清楚地知道自己在哪里还有不明白的地方。这种紧张状态很好——预示着学习的机会到来了。 二、回顾在第一步中，你不可避免地会卡壳，忘记重要的点，不能解释，或者说不能将重要的概念联系起来。 这一反馈相当宝贵，因为你已经发现了自己知识的边缘。懂得自己能力的界限也是一种能力，你刚刚就确定了一个！ 这是学习开始的地方。现在你知道自己在哪里卡住了，那么就回到原始材料，重新学习，直到你可以用基本的术语解释这一概念。 认定自己知识的界限，会限制你可能犯的错误，并且在应用该知识时，可以增加成功的几率。 三、将语言条理化，简化现在你手上有一套自己手写笔记，检查一下确保自己没有从原材料中借用任何行话。将这些笔记用简单的语言组织成一个流畅的故事。 将这个故事大声读出来，如果这些解释不够简单，或者听起来比较混乱，很好，这意味着你想要理解该领域，还需要做一些工作。 四、传授如果你真的想确保你的理解没什么问题，就把它教给另一个人（理想状态下，这个人应该对这个话题知之甚少，或者就找个 8 岁的孩子）。检测知识最终的途径是你能有能力把它传播给另一个人。 实践参考文献https://www.quora.com/Learning-New-Things/How-can-you-learn-faster/answer/Acaz-Pereira https://www.zhihu.com/question/20576786 https://wiki.mbalib.com/wiki/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>高效学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA如何实现原子操作？]]></title>
    <url>%2F2019%2F07%2F10%2Fjava%2FJAVA%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[java可以通过锁和循环CAS的方式实现原子操作。那么如何通过循环CAS的方式实现Java的原子操作呢？ 循环CAS实现原子操作循环CAS的基本思路就是通过循环执行CAS操作，直到执行成功跳出循环。以下代码实现基于CAS线程安全的计数器方法safeCount()和非线程安全计数器count。初始化100个线程，每个线程执行1w次计数,线程安全的结果应该是100w,而非线程安全的结果可能会小于这个数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Counter &#123; private AtomicInteger atomicI = new AtomicInteger(0); private int i = 0; public static void main(String[] args) &#123; final Counter cas = new Counter(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(600); long start = System.currentTimeMillis(); //初始化100个线程，每个线程执行1w次计数 for(int j=0; j&lt;100; j++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i=0; i&lt;10000; i++)&#123; cas.safeCount(); cas.count(); &#125; &#125; &#125;); threads.add(thread); &#125; for (Thread thread : threads) &#123; thread.start(); &#125; //等待所有线程执行完成 for(Thread thread : threads) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //非线程安全的结果:&lt;100w System.out.println(cas.i); //线程安全的结果: 100w System.out.println(cas.atomicI.get()); System.out.println(System.currentTimeMillis() - start); &#125; /** * 使用CAS实现线程安全计数 */ private void safeCount() &#123; //自旋CAS,直到成功跳出循环 for(;;) &#123; int i = atomicI.get(); boolean suc = atomicI.compareAndSet(i, ++i); if (suc) &#123; break; &#125; &#125; &#125; /** * 非线程安全计数 */ private void count() &#123; i++; &#125;&#125; CAS实现原子操作的问题循环CAS存在三大问题：ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作。 ABA问题什么是ABA问题？如果一个值原来是A，变成了B，又变成了A。那么CAS认为值没有发生变化，实际上是发生了变化的。 解决思路：在变量前面追加版本号A -&gt; B -&gt; A就会变成1A -&gt; 2B -&gt; 3A 这里是完整的 代码。 参考资料：方腾飞《Java并发编程的艺术》]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Climbing Stairs]]></title>
    <url>%2F2019%2F07%2F09%2FleetCode%2FClimbing%20Stairs%2F</url>
    <content type="text"><![CDATA[Climbing Stairs爬梯子问题是一个斐波那契问题，同时也是一个简单的动态规划问题，如何通过动态规划的方式解决爬梯子问题呢？ 问题描述You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2Output: 2Explanation: There are two ways to climb to the top. 1 step + 1 step 2 stepsExample 2: Input: 3Output: 3Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step 思路分析这是一个Fibonacci问题。 从动态规划的角度来看，可以看作是一个简单的动态规划问题。 针对一个动态规划问题，我们一般分为四步来进行解决： 寻找问题的最优子结构 从上往下递归 边界值 从下往上求解 代码实现递归实现： 1234567891011public int climbStairs(int n) &#123; if(0 == n) &#123; return 0; &#125; else if(1 == n) &#123; return 1; &#125; else if(2 == n) &#123; return 2; &#125; return climbStairs(n-1) + climbStairs(n-2);&#125; 递归实现的时间复杂度为O(2^n). 含有大量重复的操作。 自底向上非递归实现: 123456789101112131415161718public int climbStairs(int n) &#123; if(0 &gt;= n) &#123; return 0; &#125; else if(1 == n) &#123; return 1; &#125; else if(2 == n) &#123; return 2; &#125; int a = 1; int b = 2; for(int i = 3; i &lt;= n; i++) &#123; int temp = a + b; a = b; b = temp; &#125; return b;&#125; 非递归实现的时间复杂度为O(n), 空间复杂度为O(1). 具体代码实现 参考资料参考资料1]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北大南门海淀路社区次卧单间近爱奇艺，头条，微软]]></title>
    <url>%2F2019%2F06%2F02%2Flife%2F%E5%8C%97%E5%A4%A7%E5%8D%97%E9%97%A8%E6%B5%B7%E6%B7%80%E8%B7%AF%E7%A4%BE%E5%8C%BA%E6%AC%A1%E5%8D%A7%E5%8D%95%E9%97%B4%E8%BF%91%E7%88%B1%E5%A5%87%E8%89%BA%EF%BC%8C%E5%A4%B4%E6%9D%A1%EF%BC%8C%E5%BE%AE%E8%BD%AF%2F</url>
    <content type="text"><![CDATA[一、基本信息时间 ： 6月中旬。位置 ： 北大南门海淀路社区，近爱奇艺，头条，微软亚洲研究院等。近中关村地铁站A口，500m内。价格 ： 房租3000元一个月，押一付三。无中介费，这个价格在附近很划算。 二、房间介绍要转租的是朝北次卧，可住一到两人。房间空调，冰箱，厨房用具，热水器，暖气齐全，可能是由于给北大职工住的，冬天供暖不收费。民用峰谷电，平常5毛多，夜间2毛多。下面是房间的一些照片。[图2-1 小区门口] [图2-2 房间全局] [图2-3 窗外的景色也不错] [图2-4 房间局部 ] [图2-5 厨房] [图2-6 小区外景] [图2-7 小区外景] 三、周边介绍距离北大南门超近，周末或者晚上吃过饭后可以去北大未名湖畔溜达一圈，或者去北大五四体育场夜跑都是不错的选择。附近吃的很多，可以去食宝街，钻食街，鼎好五层，北大，人大食堂还有欧美汇，新中关gate等，也可以厨房自己DIY。小区楼下有早点，饭店，很齐全，买蔬菜水果也很方便。日常生活用品可以去附近的物美超市或者家乐福。下面是去北大溜达时候拍的一些照片。[图3-1 北大南门] [图3-2 北大百周年纪念讲堂] [图3-3 秋天的北大] [图3-4 北大五四路] [图3-5 春天北大的大雅堂] [图3-6 北大光华管理学院] 四、问题汇总【问】先问下 合同和谁签呀~【答】可以和本人签或者和中介签。和中介签需要交500转租费。 【问】你这个什么时候到期？【答】2020年4月份 【问】是几居室？有隔断吗？【答】三居室，三室一厅一厨一卫。没有隔断。 【问】除了房租、水电燃气均摊？【答】是的。 【问】厨房可用吗？【答】可以。 【问】几楼…有无电梯~【答】一共6层，房间在5楼，没有电梯。 【问】卫生间淋浴是用燃气还是用电的？【答】卫生间淋浴用燃气。 【问】房间大概多大？【答】房价大概15平左右。 【问】室友有几个人呀，都是男生女生呀？【答】三个女生 一个男生。附近上班，作息规律，都很好相处。 五、联系方式感谢您的阅读。如有意，请扫码加微信。 [图4-1 wechat]]]></content>
      <categories>
        <category>缤纷生活</category>
      </categories>
      <tags>
        <tag>缤纷生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web项目如何获取表的ddl信息？]]></title>
    <url>%2F2019%2F04%2F04%2Fjava%2FJava%20Web%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%A1%A8%E7%9A%84ddl%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[背景：公司项目是做MySQL数据向同构和异构数据库同步和消息订阅的。在做向消息中间件RMQ同步时，需要根据源表的表信息，在目标数据库创建一个相同的逻辑表。 如果是用shell的话：show create table tableName就可以搞定啦。这里一共有两个参数，第一个是table，第二个是create Table, 我们需要的就是create Table的建表语句。但是这个用Java怎么实现呢？ Mybatis这块暂且还不知道怎么实现，先通过jdbc来实现查询表的ddl语句。思路一：通过执行show create table tableName思路二：show create table tablename 和show databases 可能查的是MySQL的数据库information_schema。 123SELECT * FROM information_schema.columns where TABLE_SCHEMA = "test" AND TABLE_NAME = "example" LIMIT 10;SELECT * FROM information_schema.tables where TABLE_SCHEMA = "test" AND TABLE_NAME = "example" LIMIT 10; 可以根据以上等信息去组装ddl语句，比较复杂，而且账号的权限不一定够。所以这里按思路一的方式。首先是数据库的连接： 123456789101112131415161718192021public class DBUtil &#123; static final Logger logger = LoggerFactory.getLogger(DBUtil.class); private static final String DRIVER = "com.mysql.jdbc.Driver"; private static final String USER = "root"; private static final String PASSWORD = "admin"; private static final String DATABASE = "jdbc:mysql://127.0.0.1:3306/TEST"; public static Connection getConnection() &#123; Connection connection = null; String URL = DATABASE +"?characterEncoding=UTF-8"; try&#123; Class.forName(DRIVER); connection = DriverManager.getConnection(URL,USER,PASSWORD); &#125; catch (ClassNotFoundException | SQLException e) &#123; logger.error(URL + "连接MySQL数据库失败！", e); return null; &#125; return connection; &#125;&#125; 获取ddl语句的实现： 12345678910111213141516171819202122232425262728293031323334public void testDB() &#123; String tableName = "example"; Connection conn = DBUtil.getConnection(); String sql = String.format("SHOW CREATE TABLE %s", tableName);//查询sql //String sql = "SHOW CREATE TABLE ?"; PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); //ps.setString(1, tableName); ResultSet resultSet = ps.executeQuery(); while (resultSet.next()) &#123; System.out.println(resultSet.getString(1));//第一个参数获取的是tableName System.out.println(resultSet.getString(2));//第二个参数获取的是表的ddl语句 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null != ps)&#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(null != conn) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 查询结果: 注意：这里用ps.setString() 会在tableName上加上引号，导致MySQLSyntaxErrorException。 1show create table 'tableName' 1com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;example&apos;&apos; at line 1]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread 源码阅读]]></title>
    <url>%2F2019%2F02%2F21%2FSource%20reading%2FThread%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Thread 源码阅读 123publicclass Thread implements Runnable &#123;&#125; 所有Thread类实现了Runnable接口并实现了run()方法，为什么叫Runnable，而不是Running呢? 那是因为线程是可运行状态，并不表示此时此刻正在运行，线程的运行还需要处理器的调度。 构造方法1234public Thread(ThreadGroup group, Runnable target, String name,long stackSize) &#123;init(group, target, name, stackSize);&#125; 方法currentThread()返回当前执行线程对象的一个引用。 123456/*** Returns a reference to the currently executing thread object.** @return the currently executing thread.*/public static native Thread currentThread(); sleep(long millis)使当前执行的线程睡眠指定的 毫秒。当传入的时间millis为负数时，抛出IllegalArgumentException异常。 1public static native void sleep(long millis) throws InterruptedException; start()使当前线程开始执行。注意：一个已经执行的线程是不能执行start()方法的。 12345678910111213141516171819202122232425262728293031public synchronized void start() &#123; /** * This method is not invoked for the main method thread or "system" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state "NEW". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125; void interrupt()interrupt()中断当前线程的执行。 1234567891011121314public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0();&#125; boolean isInterrupted()检查当前线程是不是被中断。 123public boolean isInterrupted() &#123; return isInterrupted(false); &#125; 线程的优先级123456public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 线程的优先级分为10级，最小优先级为1，最大优先级为10,普通优先级为5. setDaemon(boolean on)如果on = true，则设置当前线程为守护线程。 注意：这个方法必须在线程启动前调用。 1234567public final void setDaemon(boolean on) &#123; checkAccess(); if (isAlive()) &#123; throw new IllegalThreadStateException(); &#125; daemon = on;&#125;]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring Boot继承MyBatis 如何实现多数据源动态加载？]]></title>
    <url>%2F2019%2F02%2F12%2Fjava%2FspringBoot%E7%BB%A7%E6%89%BFMyBatis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在公司的项目中遇到需要根据获取的数据库信息来动态连接数据库，执行SQL语句。通过JDBC很好实现，但是就不能使用MyBatisGenerator生成的SQL代码，需要手动写SQL了。网上能查到的教程都是Mybatis静态连接，或者多个数据源之间来回切换，不符合动态连接数据库的需求。那么如何在MyBatis里面如何实现呢？ 1.首先再resources目录下新建一个jdbc配置文件.1234huiyuan.port=com.mysql.jdbc.Driverusercloud.port=jdbc:mysql://127.0.0.1:3306/***?characterEncoding=UTF-8jdbc.username=rootjdbc.password=admin 2.配置mybatis-config.xml12345678910111213141516171819202122232425&lt;configuration&gt; &lt;properties resource="mybatis/jdbc.properties"/&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name="com.***.pojo"/&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="UNPOOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/***/mapper/DataMediaSourceMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.配置工具类关键在第三步，SqlSessionFactoryBuilder根据动态获取的数据库配置信息构建出 SqlSessionFactory 的实例，然后根据SqlSessionFactory 获取SqlSession 的实例 ，然后根据SqlSession 执行已映射的 SQL 语句 。 12345678910111213141516171819202122232425262728293031323334353637383940public class DataSourceConfig &#123; static SqlSession session; public static SqlSession getSession() &#123; return session; &#125; public static void setSession(SqlSession session) &#123; DataSourceConfig.session = session; &#125; /** * 动态获取数据库连接SqlSession * @param database * @param username * @param password * @return */ public static SqlSession getSqlSession(String database, String username, String password) &#123; Properties properties = new Properties(); properties.setProperty("jdbc.driver", "com.mysql.jdbc.Driver"); properties.setProperty("jdbc.url",database +"?characterEncoding=UTF-8"); properties.setProperty("jdbc.username", username); properties.setProperty("jdbc.password", password); String resource = "mybatis/mybatis-config.xml"; Reader reader = null; try &#123; reader = Resources.getResourceAsReader(resource); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(reader,properties); session = factory.openSession(); setSession(session); return session; &#125; &#125; 参考资料http://www.mybatis.org/mybatis-3/zh/getting-started.html]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决不同操作系统下git换行符一致性问题]]></title>
    <url>%2F2018%2F10%2F25%2Fgit%2F%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8Bgit%E6%8D%A2%E8%A1%8C%E7%AC%A6%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决不同操作系统下git换行符一致性问题新的电脑配置环境时，有可能会出现提交代码不能正确增量显示的问题。那么如何一次性解决不同操作系统下git换行符不一致的问题呢？ 一、不同操系统下的换行符CR回车 LF换行 Windows/Dos CRLF \r\n Linux/Unix LF \n MacOS CR \r 二、解决方法打卡git bash，设置core.autocrlf和core.safecrlf（可不设置），建议设置autocrlf为input，safecrlf为true，同时设置你的Eclipse、IDEA等IDE的换行符为LF\n。下面为参数说明，–global表示全局设置 2.1、autocrlf#提交时转换为LF，检出时转换为CRLFgit config --global core.autocrlf true #提交时转换为LF，检出时不转换git config --global core.autocrlf input #提交检出均不转换git config --global core.autocrlf false 2.2、safecrlf#拒绝提交包含混合换行符的文件git config --global core.safecrlf true #允许提交包含混合换行符的文件git config --global core.safecrlf false #提交包含混合换行符的文件时给出警告git config --global core.safecrlf warn]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[之江花园别墅小区 近阿里网易恒生大厦宝龙城]]></title>
    <url>%2F2018%2F10%2F25%2Flife%2F%E4%B9%8B%E6%B1%9F%E8%8A%B1%E5%9B%AD%E5%B0%8F%E5%8C%BA%20%E8%BF%91%E9%98%BF%E9%87%8C%E7%BD%91%E6%98%93%E6%81%92%E7%94%9F%2C%E5%AE%9D%E9%BE%99%E5%9F%8E%E9%99%84%E8%BF%91%2F</url>
    <content type="text"><![CDATA[基本信息时间 ： 2018年11月上旬。位置 ： 杭州市滨江区钱塘江路之江花园小区，近阿里，网易，恒生，三维等。距离地铁4号线联庄站500m内。价格 ： 租金押一付三。2150元一个月，物业费50元一个月，民用水，峰谷电，很划算。 坐标小区： 之江花园小区 距阿里网易4-5公里 距宝龙城，恒生大厦，三维1.5到2公里 小区安保很严，外来人员先核实登记才可以进入。外卖小哥哥在小区送外卖只能走路，不能骑电瓶车，心疼。 设施环境介绍空调、冰箱、洗衣机、太阳能电热水器、电视、浴霸、超大实木衣橱等设施齐全。 客厅有超大电视，华数高清数字电视付了一年，如果后来不看的话可以取消。 有超大的南北通透的客厅，客厅外有两个阳台，背面的阳台朝钱塘江，可以看到江景，看到对面的山，六和塔。 南面的阳台靠近小区，很安静，可以晾衣服，被子，采光很好。 有超大的厨房，周末可以自己diy。厨房的设备一应俱全，油烟机用的是方太的。 网费付了一年。 民用峰谷电，平常5毛多，夜间2毛多。 卧室介绍要出租的是朝南次卧，采光好，朝小区，睡觉很安静。目测大概15-18平，我不是很清楚。设施有实木的超大衣柜，实木的床，木制地板。所有房间，以及客厅都是大金中央空调，两三个空调外机，无论是制冷还是制热都没有任何压力。还有飞利浦的卧室电视，有天猫魔盒，基本上什么都能看，我用的不多，偶尔看看好声音，还有相亲类的节目看着好玩。 卫生间有全自动的太阳能热水器，可以自动上水，下雨的冬天还可以电动加热。 我们住在4楼，楼上有一个阁楼，可以放东西，很方便。 距离钱塘江的樱花跑道很近，出小区100m就到了。基本上晚上吃过饭会去钱塘江或宝龙城溜达一圈，然后回来看电视。 室友介绍两个室友都是阿里的小哥哥，素质很高。平时上班都比较忙，基本上晚上10点前很少回来过，由于我睡得比较早，他们回来的时候我差不都睡了，所以基本上是你一个人住着一套大房子。而且两位都很好相处。 主卧住了一位阿里p7的小哥哥，人很好相处。每个周末都飞回家。主卧有卫生间，阳台。所以得跟另外一位阿里小哥哥共用卫生间，这个小哥哥为人随和，生活很精致，很爱卫生。 租金租金押一付三。2150元一个月，物业费50元一个月，民用水，峰谷电，很划算。 下面是一些周边图片 联系方式感兴趣的可以扫码加微信，备注租房，谢谢。]]></content>
      <categories>
        <category>缤纷生活</category>
      </categories>
      <tags>
        <tag>缤纷生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码解析(JDK7)]]></title>
    <url>%2F2018%2F10%2F24%2FSource%20reading%2FConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88JDK7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap源码解析(JDK7) Constants (常量)12345/** * The default initial capacity for this table, * used when not otherwise specified in a constructor. */static final int DEFAULT_INITIAL_CAPACITY = 16; 默认的最初的容量为16 12345/** * The default load factor for this table, used when not * otherwise specified in a constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f; 默认的负载因子为0.75 12345/** * The default concurrency level for this table, used when not * otherwise specified in a constructor. */static final int DEFAULT_CONCURRENCY_LEVEL = 16; 默认的并发级别为16 1234567/** * The maximum capacity, used if a higher value is implicitly * specified by either of the constructors with arguments. MUST * be a power of two &lt;= 1&lt;&lt;30 to ensure that entries are indexable * using ints. */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 最大容量为2的32次幂。 123456/** * The minimum capacity for per-segment tables. Must be a power * of two, at least two to avoid immediate resizing on next use * after lazy construction. */static final int MIN_SEGMENT_TABLE_CAPACITY = 2; 最小的段数。 12345/** * The maximum number of segments to allow; used to bound * constructor arguments. Must be power of two less than 1 &lt;&lt; 24. */static final int MAX_SEGMENTS = 1 &lt;&lt; 16; // slightly conservative 略微保守的最大段数为2的16次幂。 1234567/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */static final int RETRIES_BEFORE_LOCK = 2; 字段(Fields)12345678910111213/** * A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. */private transient final int hashSeed = randomHashSeed(this);private static int randomHashSeed(ConcurrentHashMap instance) &#123; if (sun.misc.VM.isBooted() &amp;&amp; Holder.ALTERNATIVE_HASHING) &#123; return sun.misc.Hashing.randomHashSeed(instance); &#125; return 0;&#125; transient: 用transient关键字标记的成员变量不参与序列化过程。]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 源码解析(JDK1.7)]]></title>
    <url>%2F2018%2F10%2F23%2FSource%20reading%2FArrayList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK7)%2F</url>
    <content type="text"><![CDATA[ArrayList 源码解析(JDK1.7)包含的方法如下图： 所有方法按照字母a-z排序 属性DEFAULT_CAPACITY1234/** * 默认的初始容量 */private static final int DEFAULT_CAPACITY = 10; list的默认初始容量。 EMPTY_ELEMENTDATA1234/** * Shared empty array instance used for empty instances.空的对象数组 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 空的数组对象。 elementData1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == EMPTY_ELEMENTDATA will be expanded to * DEFAULT_CAPACITY when the first element is added. */private transient Object[] elementData; 当插入第一个元素的时候，空的list的容量将会从0扩展到10. size123456/** * The size of the ArrayList (the number of elements it contains). * 数组的大小 * @serial */ private int size; 数组中含有的元素的个数。 构造函数ArrayList(int initialCapacity)1234567891011121314/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity];&#125; 构造一个带有指定大小容量的list, 如果入参小于0的话则抛出IllegalArgumentException不合法的参数异常。 ArrayList()1234567/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA;&#125; 构造一个带有初始容量为10的空list。 ArrayList(Collection&lt;? extends E&gt; c)123456789101112131415/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 构造一个list包含指定容器的元素，其中的元素顺序按照容器的遍历顺序。 trimToSize()1234567891011/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = Arrays.copyOf(elementData, size); &#125;&#125; 将当前ArrayList的实例的容量调整为当前含有的元素的个数。 这个方法可以节省存储空间。 ensureCapacity(int minCapacity)1234567891011121314151617181920 /** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; //如果数组为空，minExpand容量取0，否则取默认值10 int minExpand = (elementData != EMPTY_ELEMENTDATA) // any size if real element table ? 0 // larger than default for empty table. It's already supposed to be // at default size. : DEFAULT_CAPACITY;//如果minCapacity大于minExpand,则设为最小容量 if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; size()12345678/** * Returns the number of elements in this list. * * @return the number of elements in this list */public int size() &#123; return size;&#125; 返回当前list中所含元素的个数。 isEmpty()12345678/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements */public boolean isEmpty() &#123; return size == 0;&#125; 作用：判断当前list是否为空。 如果list中所含元素个数为0的话，表示为空，返回true，否则返回false。 contains(Object o)123456789101112/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains * at least one element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this list is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 作用：判断当前list是否包含指定元素。 如果包含则返回true，不包含则返回false。 indexOf(Object o)1234567891011121314151617181920/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int indexOf(Object o) &#123; //如果对象为空的话 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 返回元素在list中的第一个索引。 lastIndexOf(Object o)12345678910111213141516171819/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 返回数组list里面匹配的最后一个元素。 clone()123456789101112131415161718/** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */public Object clone() &#123; try &#123; @SuppressWarnings("unchecked") ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; //将修改次数计数器置位0 return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125;&#125; 浅拷贝：只复制当前对象，对该对象内部的引用不能复制。 深拷贝：对对象内部的引用均复制，是创建一个新的实例，并复制实例。 返回当前数组list实例的浅拷贝(元素本身不复制)。 toArray()1234567891011121314151617/** * Returns an array containing all of the elements in this list * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be "safe" in that no references to it are * maintained by this list. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this list in * proper sequence */public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; 以合适的顺序（从第一个到最后一个元素）返回当前list中的所有元素到一个数组 返回一个数组，这个数组包含当前list的所有元素，并且以从第一个到最后一个元素的顺序。 toArray(T[] a)get(int index)123456789101112/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; rangeCheck(index); //对index进行检查，是否超出了边界 return elementData(index);&#125; 返回指定位置上的元素。]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object源码解析(JDK1.8)]]></title>
    <url>%2F2018%2F10%2F21%2FSource%20reading%2FObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8)%2F</url>
    <content type="text"><![CDATA[Object源码解析(JDK1.8)Object类是Java中所有类的基类，在编译时会自动导入，位于java.lang包中，而Object中具有的属性和行为，是Java语言设计背后的思维体现。这里写的代码是JDK8中的，其他版本的JDK可能略有不同。 包含的方法如下图： 所有方法按照字母a-z排序 Object类方法说明： Object类中的方法大部分都是native方法（如上图中方法前有一个绿色的实心小圆圈，圆圈的右上角有大写字母N，表示该方法是一个native方法），用此关键字修饰的方法是java中的本地方法，一般都是用C/C++语言实现的。 构造方法Object类中没有显示的提供构造方法，是编译器默认提供的。 registerNatives()方法1234private static native void registerNatives();static &#123; registerNatives();&#125; registerNatives()是一个本地方法，具体是用C/C++在DLL中实现的，在类加载的时候执行。private修饰使方法私有化，在类加载时执行静态代码块调用该方法。 getClass()方法1234567891011121314151617181920/** * Returns the runtime class of this &#123;@code Object&#125;. The returned * &#123;@code Class&#125; object is the object that is locked by &#123;@code * static synchronized&#125; methods of the represented class. * * &lt;p&gt;&lt;b&gt;The actual result type is &#123;@code Class&lt;? extends |X|&gt;&#125; * where &#123;@code |X|&#125; is the erasure of the static type of the * expression on which &#123;@code getClass&#125; is called.&lt;/b&gt; For * example, no cast is required in this code fragment:&lt;/p&gt; * * &lt;p&gt; * &#123;@code Number n = 0; &#125;&lt;br&gt; * &#123;@code Class&lt;? extends Number&gt; c = n.getClass(); &#125; * &lt;/p&gt; * * @return The &#123;@code Class&#125; object that represents the runtime * class of this object. * @jls 15.8.2 Class Literals */public final native Class&lt;?&gt; getClass(); getClass() 被native修饰，同样也是调用本地方法实现的。返回当前对象运行时的类，final关键字修饰说明这个方法不能被子类重写。 hashcode()方法123456789101112131415161718192021222324252627282930313233343536/** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * &#123;@link java.util.HashMap&#125;. * &lt;p&gt; * The general contract of &#123;@code hashCode&#125; is: * &lt;ul&gt; * &lt;li&gt;Whenever it is invoked on the same object more than once during * an execution of a Java application, the &#123;@code hashCode&#125; method * must consistently return the same integer, provided no information * used in &#123;@code equals&#125; comparisons on the object is modified. * This integer need not remain consistent from one execution of an * application to another execution of the same application. * &lt;li&gt;If two objects are equal according to the &#123;@code equals(Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of * the two objects must produce the same integer result. * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal * according to the &#123;@link java.lang.Object#equals(java.lang.Object)&#125; * method, then calling the &#123;@code hashCode&#125; method on each of the * two objects must produce distinct integer results. However, the * programmer should be aware that producing distinct integer results * for unequal objects may improve the performance of hash tables. * &lt;/ul&gt; * &lt;p&gt; * As much as is reasonably practical, the hashCode method defined by * class &#123;@code Object&#125; does return distinct integers for distinct * objects. (This is typically implemented by converting the internal * address of the object into an integer, but this implementation * technique is not required by the * Java&amp;trade; programming language.) * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */public native int hashCode(); Object类中的hashcode()方法用来鉴定两个对象是否相等，返回对象在内存中地址转换成的一个 int类型的值。如果没有重写hashcode()方法，任何对象的hashcode()方法都是不相等的。 equals()方法入参：Object 返回值：Boolean类型 123public boolean equals(Object obj) &#123; return (this == obj);&#125; Object类中的equals()方法用来判断两个对象是否相等。如果当前对象与传入的对象相同，则返回true，否则返回false。 注意：这个equals()方法没有被final关键字修饰，也就是说可以被子类重写，比如说String类型里面重写了equals()方法，如下： 12345678910111213141516171819202122232425262728public boolean equals(Object anObject) &#123; //如果对象相等的话，直接返回true if (this == anObject) &#123; return true; &#125; /** * 如果对象不相同，则比较String中的value值是否相同。 * 首先判断传入的对象是不是String类型的实例： * 如果是，将字符串转换成字符数组接着逐一比较数组里的字符是否相同，如果不同，直接返回false。 * 遍历结束，则表示相同，返回true。 * */ if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 如果传入的对象和当前对象是同一个对象，返回true；如果传入的对象是String类型的实例，则判断传入对象的String和当前String是否相等，如果相等，则返回true，否则返回false。 instanceof关键字的作用：判断左边的对象是否是右边类的实例，例如 objectA.instanceof(ClassB)判断对象A是否是类B的实例，如果是则返回true，否则返回false。 clone()方法1protected native Object clone() throws CloneNotSupportedException; 返回当前实例的克隆对象。 toString()方法123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; 返回表示当前对象的字符串，字符串的形式是类名@hashCode的十六进制表示，比如objectA是classB的实例，ObjectA的hashCode为c,而c的十六进制为d,则调用ObjectA的toString()方法返回ClassB@d。推荐所有的子类都重写这个方法。 notify()方法1public final native void notify(); 唤醒在该对象监视器(Monitor)里等待的一个线程。 notifyAll()方法1public final native void notifyAll(); 唤醒当前对象监视器下的所有线程。 wait(long)方法1public final native void wait(long timeout) throws InterruptedException; 使当前线程等待直到另外一个线程调用等待线程的notify()方法或者notifyAll()方法，或者等待指定的时间。 wait(long,int)方法12345678910111213141516public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout);&#125; 和只有一个入参的wait(long)方法类似，但它允许更精细的时间控制，以纳秒进行实时的统计。 wait()方法123public final void wait() throws InterruptedException &#123; wait(0);&#125; finalize()方法1protected void finalize() throws Throwable &#123; &#125; JAVA内存回收机制是通过根节点到当前对象之间有没有一条引用链指向来判断对象是否可以回收的。 该对象没有引用指向的时候，垃圾收集器在合适的时机调用该对象的finalize()方法对该对象进行回收。 参考资料 https://blog.csdn.net/benjaminlee1/article/details/72843713]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>缤纷生活</category>
      </categories>
      <tags>
        <tag>缤纷生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2018%2F07%2F14%2Fdesign%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式工厂模式属于创建型模式，提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时，不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 介绍意图：定义一个创建对象的接口，让子类决定实例化哪一个工厂类。 主要解决：接口选择问题 如何解决：子类实现工厂接口，返回抽象产品 使用场景：设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 实现我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。FactoryPatternDemo*，我们的演示类使用 *ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 创建一个接口 1234public interface Shape &#123; void draw();&#125; 创建实现接口的实体类 12345678public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; 12345678public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; 12345678public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 创建一个工厂，生成基于给定信息的实体类的对象。 123456789101112131415161718public class ShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125;&#125; 使用该工厂，通过传递类型信息来获取实体类的对象。 12345678910111213141516171819202122232425public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape("CIRCLE"); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape("RECTANGLE"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape("SQUARE"); //调用 Square 的 draw 方法 shape3.draw(); &#125;&#125; 执行程序，输出结果。 123Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method. 参考资料https://www.runoob.com/design-pattern/design-pattern-tutorial.html]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F07%2F07%2Fdesign%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 介绍意图：保证一个类只有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁的被创建和销毁。 关键代码：构造函数私有化。 优点：在内存里只有一个实例，减小了对内存的开销。 缺点：没有接口，不能继承，与单一职责冲突，一个类只关心内部逻辑，而不关心外面怎么实现它。 使用场景： 要求生产序列号唯一 web中的计数器，不想每次刷新都在数据库中加一次，用单例模式先缓存起来。 创建一个对象需要消耗的资源过多，比如I/O与数据库的连接等。 实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。 SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo*，我们的演示类使用 *SingleObject 类来获取 SingleObject 对象。 创建一个Singleton类 123456789101112131415161718public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println("Hello World!"); &#125;&#125; 从Singleton类获取唯一个对象。 1234567891011121314public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125; 执行程序，输出结果： 1Hello World! 单例模式的几种实现方式一、懒汉式，线程不安全是否lazy初始化： 是 是否多线程安全：否 实现难度：容易 描述：这种方式是最进本的实现方式，最大的问题是不支持多线程。因为没有加synchronized，当多线程访问的时候，可能同时创建多个实例，所以从多线程上来看，并不算作单例模式。 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 123456789101112public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。 二、懒汉式，线程安全是否lazy初始化：是 是否线程安全：是 实现难度：容易 描述：具备很好的lazy loading, 多线程安全，但是效率低下。 优点：懒加载，避免内存浪费。 缺点： 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 三、饿汉式是否lazy初始化：否 是否多线程安全：是 实现难度：容易 描述：这种方法比较常用，但是容易产生垃圾对象。 优点：没有加锁，执行效率高。 缺点：类加载时就初始化，浪费内存。 12345678public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 四、双检锁/双重校验锁（DCL，即 double-checked locking）是否lazy初始化：是 是否多线程安全：是 实现难度：较复杂 描述：这种方式线程安全，且在多线程的情况下，能保证高性能。 123456789101112131415public class Singleton &#123; private volatile static Singleton singleton; //多线程访问情形下，阻止编译器自动优化。 private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (null == singleton) &#123; synchronized (Singleton.class) &#123; if (null == singleton) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 五、静态内部类优点：实现简单，需要时加载，线程安全。 1234567891011121314151617public class Singleton &#123; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public void showMsg() &#123; System.out.println("Hello World!"); &#125;&#125; 六、枚举优点:更简洁，自动支持序列化机制，绝对防止多次实例化,避免多线程同步 12345678public enum Singleton &#123; INSTANCE; public void showMsg() &#123; System.out.println("Hello World!"); &#125;&#125; 调用： 1234567public class SingletonDemo &#123; public static void main(String[] args) &#123; Singleton.INSTANCE.showMsg(); &#125;&#125; 详细代码实现 应用java.util.Collections 是针对集合类的包装类，它的实现用到了单例模式，通过私有化构造方法，然后将所有的方法都用static关键字修饰。（类方法？） 1234567891011public class Collections &#123; // 构造方法私有化，确保不被实例化 private Collections() &#123; &#125; // 方法使用static关键字修饰 public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123; list.sort(null); &#125; ...&#125; 参考资料https://www.runoob.com/design-pattern/design-pattern-tutorial.html]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F07%2F02%2Fdesign%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[​ 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式的分类有以上思维导图可以看出，设计模式可以分为创建型，结构型和行为型模式。 设计模式的六大原则开闭原则解释：对扩展开放，对修改封闭。 作用：使程序的扩展性好，易于维护和升级。 实现：使用接口和抽象类。 李氏替换任何基类可以出现的地方，子类一定可以出现。 作用：复用基类 依赖倒置面向接口编程，依赖于抽象，而不是依赖于具体。 接口隔离使用多个隔离的接口，比使用单个接口好。 作用：降低依赖，解耦。 迪米特法则一个实体类应该j尽量少的与其他实体类之间互相作用，使系统的各功能模块相对独立。 合成复用原则尽量使用组合，聚合的方式，避免使用继承。]]></content>
      <categories>
        <category>好好学习</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
</search>
